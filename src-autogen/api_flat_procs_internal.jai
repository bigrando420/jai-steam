#scope_module


// ISteamClient
SteamAPI_ISteamClient_CreateSteamPipe :: (self: *ISteamClient) -> HSteamPipe #foreign steam "SteamAPI_ISteamClient_CreateSteamPipe";
SteamAPI_ISteamClient_BReleaseSteamPipe :: (self: *ISteamClient, hSteamPipe: HSteamPipe) -> bool #foreign steam "SteamAPI_ISteamClient_BReleaseSteamPipe";
SteamAPI_ISteamClient_ConnectToGlobalUser :: (self: *ISteamClient, hSteamPipe: HSteamPipe) -> HSteamUser #foreign steam "SteamAPI_ISteamClient_ConnectToGlobalUser";
SteamAPI_ISteamClient_CreateLocalUser :: (self: *ISteamClient, phSteamPipe: *HSteamPipe, eAccountType: EAccountType) -> HSteamUser #foreign steam "SteamAPI_ISteamClient_CreateLocalUser";
SteamAPI_ISteamClient_ReleaseUser :: (self: *ISteamClient, hSteamPipe: HSteamPipe, hUser: HSteamUser) #foreign steam "SteamAPI_ISteamClient_ReleaseUser";
SteamAPI_ISteamClient_GetISteamUser :: (self: *ISteamClient, hSteamUser: HSteamUser, hSteamPipe: HSteamPipe, pchVersion: *char) -> *ISteamUser #foreign steam "SteamAPI_ISteamClient_GetISteamUser";
SteamAPI_ISteamClient_GetISteamGameServer :: (self: *ISteamClient, hSteamUser: HSteamUser, hSteamPipe: HSteamPipe, pchVersion: *char) -> *ISteamGameServer #foreign steam "SteamAPI_ISteamClient_GetISteamGameServer";
SteamAPI_ISteamClient_SetLocalIPBinding :: (self: *ISteamClient, unIP: *SteamIPAddress_t, usPort: uint16) #foreign steam "SteamAPI_ISteamClient_SetLocalIPBinding";
SteamAPI_ISteamClient_GetISteamFriends :: (self: *ISteamClient, hSteamUser: HSteamUser, hSteamPipe: HSteamPipe, pchVersion: *char) -> *ISteamFriends #foreign steam "SteamAPI_ISteamClient_GetISteamFriends";
SteamAPI_ISteamClient_GetISteamUtils :: (self: *ISteamClient, hSteamPipe: HSteamPipe, pchVersion: *char) -> *ISteamUtils #foreign steam "SteamAPI_ISteamClient_GetISteamUtils";
SteamAPI_ISteamClient_GetISteamMatchmaking :: (self: *ISteamClient, hSteamUser: HSteamUser, hSteamPipe: HSteamPipe, pchVersion: *char) -> *ISteamMatchmaking #foreign steam "SteamAPI_ISteamClient_GetISteamMatchmaking";
SteamAPI_ISteamClient_GetISteamMatchmakingServers :: (self: *ISteamClient, hSteamUser: HSteamUser, hSteamPipe: HSteamPipe, pchVersion: *char) -> *ISteamMatchmakingServers #foreign steam "SteamAPI_ISteamClient_GetISteamMatchmakingServers";
SteamAPI_ISteamClient_GetISteamGenericInterface :: (self: *ISteamClient, hSteamUser: HSteamUser, hSteamPipe: HSteamPipe, pchVersion: *char) #foreign steam "SteamAPI_ISteamClient_GetISteamGenericInterface";
SteamAPI_ISteamClient_GetISteamUserStats :: (self: *ISteamClient, hSteamUser: HSteamUser, hSteamPipe: HSteamPipe, pchVersion: *char) -> *ISteamUserStats #foreign steam "SteamAPI_ISteamClient_GetISteamUserStats";
SteamAPI_ISteamClient_GetISteamGameServerStats :: (self: *ISteamClient, hSteamuser: HSteamUser, hSteamPipe: HSteamPipe, pchVersion: *char) -> *ISteamGameServerStats #foreign steam "SteamAPI_ISteamClient_GetISteamGameServerStats";
SteamAPI_ISteamClient_GetISteamApps :: (self: *ISteamClient, hSteamUser: HSteamUser, hSteamPipe: HSteamPipe, pchVersion: *char) -> *ISteamApps #foreign steam "SteamAPI_ISteamClient_GetISteamApps";
SteamAPI_ISteamClient_GetISteamNetworking :: (self: *ISteamClient, hSteamUser: HSteamUser, hSteamPipe: HSteamPipe, pchVersion: *char) -> *ISteamNetworking #foreign steam "SteamAPI_ISteamClient_GetISteamNetworking";
SteamAPI_ISteamClient_GetISteamRemoteStorage :: (self: *ISteamClient, hSteamuser: HSteamUser, hSteamPipe: HSteamPipe, pchVersion: *char) -> *ISteamRemoteStorage #foreign steam "SteamAPI_ISteamClient_GetISteamRemoteStorage";
SteamAPI_ISteamClient_GetISteamScreenshots :: (self: *ISteamClient, hSteamuser: HSteamUser, hSteamPipe: HSteamPipe, pchVersion: *char) -> *ISteamScreenshots #foreign steam "SteamAPI_ISteamClient_GetISteamScreenshots";
SteamAPI_ISteamClient_GetISteamGameSearch :: (self: *ISteamClient, hSteamuser: HSteamUser, hSteamPipe: HSteamPipe, pchVersion: *char) -> *ISteamGameSearch #foreign steam "SteamAPI_ISteamClient_GetISteamGameSearch";
SteamAPI_ISteamClient_GetIPCCallCount :: (self: *ISteamClient) -> uint32 #foreign steam "SteamAPI_ISteamClient_GetIPCCallCount";
SteamAPI_ISteamClient_SetWarningMessageHook :: (self: *ISteamClient, pFunction: SteamAPIWarningMessageHook_t) #foreign steam "SteamAPI_ISteamClient_SetWarningMessageHook";
SteamAPI_ISteamClient_BShutdownIfAllPipesClosed :: (self: *ISteamClient) -> bool #foreign steam "SteamAPI_ISteamClient_BShutdownIfAllPipesClosed";
SteamAPI_ISteamClient_GetISteamHTTP :: (self: *ISteamClient, hSteamuser: HSteamUser, hSteamPipe: HSteamPipe, pchVersion: *char) -> *ISteamHTTP #foreign steam "SteamAPI_ISteamClient_GetISteamHTTP";
SteamAPI_ISteamClient_GetISteamController :: (self: *ISteamClient, hSteamUser: HSteamUser, hSteamPipe: HSteamPipe, pchVersion: *char) -> *ISteamController #foreign steam "SteamAPI_ISteamClient_GetISteamController";
SteamAPI_ISteamClient_GetISteamUGC :: (self: *ISteamClient, hSteamUser: HSteamUser, hSteamPipe: HSteamPipe, pchVersion: *char) -> *ISteamUGC #foreign steam "SteamAPI_ISteamClient_GetISteamUGC";
SteamAPI_ISteamClient_GetISteamAppList :: (self: *ISteamClient, hSteamUser: HSteamUser, hSteamPipe: HSteamPipe, pchVersion: *char) -> *ISteamAppList #foreign steam "SteamAPI_ISteamClient_GetISteamAppList";
SteamAPI_ISteamClient_GetISteamMusic :: (self: *ISteamClient, hSteamuser: HSteamUser, hSteamPipe: HSteamPipe, pchVersion: *char) -> *ISteamMusic #foreign steam "SteamAPI_ISteamClient_GetISteamMusic";
SteamAPI_ISteamClient_GetISteamMusicRemote :: (self: *ISteamClient, hSteamuser: HSteamUser, hSteamPipe: HSteamPipe, pchVersion: *char) -> *ISteamMusicRemote #foreign steam "SteamAPI_ISteamClient_GetISteamMusicRemote";
SteamAPI_ISteamClient_GetISteamHTMLSurface :: (self: *ISteamClient, hSteamuser: HSteamUser, hSteamPipe: HSteamPipe, pchVersion: *char) -> *ISteamHTMLSurface #foreign steam "SteamAPI_ISteamClient_GetISteamHTMLSurface";
SteamAPI_ISteamClient_GetISteamInventory :: (self: *ISteamClient, hSteamuser: HSteamUser, hSteamPipe: HSteamPipe, pchVersion: *char) -> *ISteamInventory #foreign steam "SteamAPI_ISteamClient_GetISteamInventory";
SteamAPI_ISteamClient_GetISteamVideo :: (self: *ISteamClient, hSteamuser: HSteamUser, hSteamPipe: HSteamPipe, pchVersion: *char) -> *ISteamVideo #foreign steam "SteamAPI_ISteamClient_GetISteamVideo";
SteamAPI_ISteamClient_GetISteamParentalSettings :: (self: *ISteamClient, hSteamuser: HSteamUser, hSteamPipe: HSteamPipe, pchVersion: *char) -> *ISteamParentalSettings #foreign steam "SteamAPI_ISteamClient_GetISteamParentalSettings";
SteamAPI_ISteamClient_GetISteamInput :: (self: *ISteamClient, hSteamUser: HSteamUser, hSteamPipe: HSteamPipe, pchVersion: *char) -> *ISteamInput #foreign steam "SteamAPI_ISteamClient_GetISteamInput";
SteamAPI_ISteamClient_GetISteamParties :: (self: *ISteamClient, hSteamUser: HSteamUser, hSteamPipe: HSteamPipe, pchVersion: *char) -> *ISteamParties #foreign steam "SteamAPI_ISteamClient_GetISteamParties";
SteamAPI_ISteamClient_GetISteamRemotePlay :: (self: *ISteamClient, hSteamUser: HSteamUser, hSteamPipe: HSteamPipe, pchVersion: *char) -> *ISteamRemotePlay #foreign steam "SteamAPI_ISteamClient_GetISteamRemotePlay";

// ISteamUser
SteamAPI_SteamUser_v021 :: () -> *ISteamUser #foreign steam "SteamAPI_SteamUser_v021";
SteamAPI_ISteamUser_GetHSteamUser :: (self: *ISteamUser) -> HSteamUser #foreign steam "SteamAPI_ISteamUser_GetHSteamUser";
SteamAPI_ISteamUser_BLoggedOn :: (self: *ISteamUser) -> bool #foreign steam "SteamAPI_ISteamUser_BLoggedOn";
SteamAPI_ISteamUser_GetSteamID :: (self: *ISteamUser) -> uint64_steamid #foreign steam "SteamAPI_ISteamUser_GetSteamID";
SteamAPI_ISteamUser_InitiateGameConnection :: (self: *ISteamUser, pAuthBlob: *void, cbMaxAuthBlob: s32, steamIDGameServer: uint64_steamid, unIPServer: uint32, usPortServer: uint16, bSecure: bool) -> s32 #foreign steam "SteamAPI_ISteamUser_InitiateGameConnection";
SteamAPI_ISteamUser_TerminateGameConnection :: (self: *ISteamUser, unIPServer: uint32, usPortServer: uint16) #foreign steam "SteamAPI_ISteamUser_TerminateGameConnection";
SteamAPI_ISteamUser_TrackAppUsageEvent :: (self: *ISteamUser, gameID: uint64_gameid, eAppUsageEvent: s32, pchExtraInfo: *char) #foreign steam "SteamAPI_ISteamUser_TrackAppUsageEvent";
SteamAPI_ISteamUser_GetUserDataFolder :: (self: *ISteamUser, pchBuffer: *char, cubBuffer: s32) -> bool #foreign steam "SteamAPI_ISteamUser_GetUserDataFolder";
SteamAPI_ISteamUser_StartVoiceRecording :: (self: *ISteamUser) #foreign steam "SteamAPI_ISteamUser_StartVoiceRecording";
SteamAPI_ISteamUser_StopVoiceRecording :: (self: *ISteamUser) #foreign steam "SteamAPI_ISteamUser_StopVoiceRecording";
SteamAPI_ISteamUser_GetAvailableVoice :: (self: *ISteamUser, pcbCompressed: *uint32, pcbUncompressed_Deprecated: *uint32, nUncompressedVoiceDesiredSampleRate_Deprecated: uint32) -> EVoiceResult #foreign steam "SteamAPI_ISteamUser_GetAvailableVoice";
SteamAPI_ISteamUser_GetVoice :: (self: *ISteamUser, bWantCompressed: bool, pDestBuffer: *void, cbDestBufferSize: uint32, nBytesWritten: *uint32, bWantUncompressed_Deprecated: bool, pUncompressedDestBuffer_Deprecated: *void, cbUncompressedDestBufferSize_Deprecated: uint32, nUncompressBytesWritten_Deprecated: *uint32, nUncompressedVoiceDesiredSampleRate_Deprecated: uint32) -> EVoiceResult #foreign steam "SteamAPI_ISteamUser_GetVoice";
SteamAPI_ISteamUser_DecompressVoice :: (self: *ISteamUser, pCompressed: *void, cbCompressed: uint32, pDestBuffer: *void, cbDestBufferSize: uint32, nBytesWritten: *uint32, nDesiredSampleRate: uint32) -> EVoiceResult #foreign steam "SteamAPI_ISteamUser_DecompressVoice";
SteamAPI_ISteamUser_GetVoiceOptimalSampleRate :: (self: *ISteamUser) -> uint32 #foreign steam "SteamAPI_ISteamUser_GetVoiceOptimalSampleRate";
SteamAPI_ISteamUser_GetAuthSessionTicket :: (self: *ISteamUser, pTicket: *void, cbMaxTicket: s32, pcbTicket: *uint32) -> HAuthTicket #foreign steam "SteamAPI_ISteamUser_GetAuthSessionTicket";
SteamAPI_ISteamUser_BeginAuthSession :: (self: *ISteamUser, pAuthTicket: *void, cbAuthTicket: s32, steamID: uint64_steamid) -> EBeginAuthSessionResult #foreign steam "SteamAPI_ISteamUser_BeginAuthSession";
SteamAPI_ISteamUser_EndAuthSession :: (self: *ISteamUser, steamID: uint64_steamid) #foreign steam "SteamAPI_ISteamUser_EndAuthSession";
SteamAPI_ISteamUser_CancelAuthTicket :: (self: *ISteamUser, hAuthTicket: HAuthTicket) #foreign steam "SteamAPI_ISteamUser_CancelAuthTicket";
SteamAPI_ISteamUser_UserHasLicenseForApp :: (self: *ISteamUser, steamID: uint64_steamid, appID: AppId_t) -> EUserHasLicenseForAppResult #foreign steam "SteamAPI_ISteamUser_UserHasLicenseForApp";
SteamAPI_ISteamUser_BIsBehindNAT :: (self: *ISteamUser) -> bool #foreign steam "SteamAPI_ISteamUser_BIsBehindNAT";
SteamAPI_ISteamUser_AdvertiseGame :: (self: *ISteamUser, steamIDGameServer: uint64_steamid, unIPServer: uint32, usPortServer: uint16) #foreign steam "SteamAPI_ISteamUser_AdvertiseGame";
SteamAPI_ISteamUser_RequestEncryptedAppTicket :: (self: *ISteamUser, pDataToInclude: *void, cbDataToInclude: s32) -> SteamAPICall_t #must #foreign steam "SteamAPI_ISteamUser_RequestEncryptedAppTicket";
SteamAPI_ISteamUser_GetEncryptedAppTicket :: (self: *ISteamUser, pTicket: *void, cbMaxTicket: s32, pcbTicket: *uint32) -> bool #foreign steam "SteamAPI_ISteamUser_GetEncryptedAppTicket";
SteamAPI_ISteamUser_GetGameBadgeLevel :: (self: *ISteamUser, nSeries: s32, bFoil: bool) -> s32 #foreign steam "SteamAPI_ISteamUser_GetGameBadgeLevel";
SteamAPI_ISteamUser_GetPlayerSteamLevel :: (self: *ISteamUser) -> s32 #foreign steam "SteamAPI_ISteamUser_GetPlayerSteamLevel";
SteamAPI_ISteamUser_RequestStoreAuthURL :: (self: *ISteamUser, pchRedirectURL: *char) -> SteamAPICall_t #must #foreign steam "SteamAPI_ISteamUser_RequestStoreAuthURL";
SteamAPI_ISteamUser_BIsPhoneVerified :: (self: *ISteamUser) -> bool #foreign steam "SteamAPI_ISteamUser_BIsPhoneVerified";
SteamAPI_ISteamUser_BIsTwoFactorEnabled :: (self: *ISteamUser) -> bool #foreign steam "SteamAPI_ISteamUser_BIsTwoFactorEnabled";
SteamAPI_ISteamUser_BIsPhoneIdentifying :: (self: *ISteamUser) -> bool #foreign steam "SteamAPI_ISteamUser_BIsPhoneIdentifying";
SteamAPI_ISteamUser_BIsPhoneRequiringVerification :: (self: *ISteamUser) -> bool #foreign steam "SteamAPI_ISteamUser_BIsPhoneRequiringVerification";
SteamAPI_ISteamUser_GetMarketEligibility :: (self: *ISteamUser) -> SteamAPICall_t #must #foreign steam "SteamAPI_ISteamUser_GetMarketEligibility";
SteamAPI_ISteamUser_GetDurationControl :: (self: *ISteamUser) -> SteamAPICall_t #must #foreign steam "SteamAPI_ISteamUser_GetDurationControl";
SteamAPI_ISteamUser_BSetDurationControlOnlineState :: (self: *ISteamUser, eNewState: EDurationControlOnlineState) -> bool #foreign steam "SteamAPI_ISteamUser_BSetDurationControlOnlineState";

// ISteamFriends
SteamAPI_SteamFriends_v017 :: () -> *ISteamFriends #foreign steam "SteamAPI_SteamFriends_v017";
SteamAPI_ISteamFriends_GetPersonaName :: (self: *ISteamFriends) -> *char #foreign steam "SteamAPI_ISteamFriends_GetPersonaName";
SteamAPI_ISteamFriends_SetPersonaName :: (self: *ISteamFriends, pchPersonaName: *char) -> SteamAPICall_t #must #foreign steam "SteamAPI_ISteamFriends_SetPersonaName";
SteamAPI_ISteamFriends_GetPersonaState :: (self: *ISteamFriends) -> EPersonaState #foreign steam "SteamAPI_ISteamFriends_GetPersonaState";
SteamAPI_ISteamFriends_GetFriendCount :: (self: *ISteamFriends, iFriendFlags: EFriendFlags) -> s32 #foreign steam "SteamAPI_ISteamFriends_GetFriendCount";
SteamAPI_ISteamFriends_GetFriendByIndex :: (self: *ISteamFriends, iFriend: s32, iFriendFlags: EFriendFlags) -> uint64_steamid #foreign steam "SteamAPI_ISteamFriends_GetFriendByIndex";
SteamAPI_ISteamFriends_GetFriendRelationship :: (self: *ISteamFriends, steamIDFriend: uint64_steamid) -> EFriendRelationship #foreign steam "SteamAPI_ISteamFriends_GetFriendRelationship";
SteamAPI_ISteamFriends_GetFriendPersonaState :: (self: *ISteamFriends, steamIDFriend: uint64_steamid) -> EPersonaState #foreign steam "SteamAPI_ISteamFriends_GetFriendPersonaState";
SteamAPI_ISteamFriends_GetFriendPersonaName :: (self: *ISteamFriends, steamIDFriend: uint64_steamid) -> *char #foreign steam "SteamAPI_ISteamFriends_GetFriendPersonaName";
SteamAPI_ISteamFriends_GetFriendGamePlayed :: (self: *ISteamFriends, steamIDFriend: uint64_steamid, pFriendGameInfo: *FriendGameInfo_t) -> bool #foreign steam "SteamAPI_ISteamFriends_GetFriendGamePlayed";
SteamAPI_ISteamFriends_GetFriendPersonaNameHistory :: (self: *ISteamFriends, steamIDFriend: uint64_steamid, iPersonaName: s32) -> *char #foreign steam "SteamAPI_ISteamFriends_GetFriendPersonaNameHistory";
SteamAPI_ISteamFriends_GetFriendSteamLevel :: (self: *ISteamFriends, steamIDFriend: uint64_steamid) -> s32 #foreign steam "SteamAPI_ISteamFriends_GetFriendSteamLevel";
SteamAPI_ISteamFriends_GetPlayerNickname :: (self: *ISteamFriends, steamIDPlayer: uint64_steamid) -> *char #foreign steam "SteamAPI_ISteamFriends_GetPlayerNickname";
SteamAPI_ISteamFriends_GetFriendsGroupCount :: (self: *ISteamFriends) -> s32 #foreign steam "SteamAPI_ISteamFriends_GetFriendsGroupCount";
SteamAPI_ISteamFriends_GetFriendsGroupIDByIndex :: (self: *ISteamFriends, iFG: s32) -> FriendsGroupID_t #foreign steam "SteamAPI_ISteamFriends_GetFriendsGroupIDByIndex";
SteamAPI_ISteamFriends_GetFriendsGroupName :: (self: *ISteamFriends, friendsGroupID: FriendsGroupID_t) -> *char #foreign steam "SteamAPI_ISteamFriends_GetFriendsGroupName";
SteamAPI_ISteamFriends_GetFriendsGroupMembersCount :: (self: *ISteamFriends, friendsGroupID: FriendsGroupID_t) -> s32 #foreign steam "SteamAPI_ISteamFriends_GetFriendsGroupMembersCount";
SteamAPI_ISteamFriends_GetFriendsGroupMembersList :: (self: *ISteamFriends, friendsGroupID: FriendsGroupID_t, pOutSteamIDMembers: *CSteamID, nMembersCount: s32) #foreign steam "SteamAPI_ISteamFriends_GetFriendsGroupMembersList";
SteamAPI_ISteamFriends_HasFriend :: (self: *ISteamFriends, steamIDFriend: uint64_steamid, iFriendFlags: EFriendFlags) -> bool #foreign steam "SteamAPI_ISteamFriends_HasFriend";
SteamAPI_ISteamFriends_GetClanCount :: (self: *ISteamFriends) -> s32 #foreign steam "SteamAPI_ISteamFriends_GetClanCount";
SteamAPI_ISteamFriends_GetClanByIndex :: (self: *ISteamFriends, iClan: s32) -> uint64_steamid #foreign steam "SteamAPI_ISteamFriends_GetClanByIndex";
SteamAPI_ISteamFriends_GetClanName :: (self: *ISteamFriends, steamIDClan: uint64_steamid) -> *char #foreign steam "SteamAPI_ISteamFriends_GetClanName";
SteamAPI_ISteamFriends_GetClanTag :: (self: *ISteamFriends, steamIDClan: uint64_steamid) -> *char #foreign steam "SteamAPI_ISteamFriends_GetClanTag";
SteamAPI_ISteamFriends_GetClanActivityCounts :: (self: *ISteamFriends, steamIDClan: uint64_steamid, pnOnline: *s32, pnInGame: *s32, pnChatting: *s32) -> bool #foreign steam "SteamAPI_ISteamFriends_GetClanActivityCounts";
SteamAPI_ISteamFriends_DownloadClanActivityCounts :: (self: *ISteamFriends, psteamIDClans: *CSteamID, cClansToRequest: s32) -> SteamAPICall_t #must #foreign steam "SteamAPI_ISteamFriends_DownloadClanActivityCounts";
SteamAPI_ISteamFriends_GetFriendCountFromSource :: (self: *ISteamFriends, steamIDSource: uint64_steamid) -> s32 #foreign steam "SteamAPI_ISteamFriends_GetFriendCountFromSource";
SteamAPI_ISteamFriends_GetFriendFromSourceByIndex :: (self: *ISteamFriends, steamIDSource: uint64_steamid, iFriend: s32) -> uint64_steamid #foreign steam "SteamAPI_ISteamFriends_GetFriendFromSourceByIndex";
SteamAPI_ISteamFriends_IsUserInSource :: (self: *ISteamFriends, steamIDUser: uint64_steamid, steamIDSource: uint64_steamid) -> bool #foreign steam "SteamAPI_ISteamFriends_IsUserInSource";
SteamAPI_ISteamFriends_SetInGameVoiceSpeaking :: (self: *ISteamFriends, steamIDUser: uint64_steamid, bSpeaking: bool) #foreign steam "SteamAPI_ISteamFriends_SetInGameVoiceSpeaking";
SteamAPI_ISteamFriends_ActivateGameOverlay :: (self: *ISteamFriends, pchDialog: *char) #foreign steam "SteamAPI_ISteamFriends_ActivateGameOverlay";
SteamAPI_ISteamFriends_ActivateGameOverlayToUser :: (self: *ISteamFriends, pchDialog: *char, steamID: uint64_steamid) #foreign steam "SteamAPI_ISteamFriends_ActivateGameOverlayToUser";
SteamAPI_ISteamFriends_ActivateGameOverlayToWebPage :: (self: *ISteamFriends, pchURL: *char, eMode: EActivateGameOverlayToWebPageMode) #foreign steam "SteamAPI_ISteamFriends_ActivateGameOverlayToWebPage";
SteamAPI_ISteamFriends_ActivateGameOverlayToStore :: (self: *ISteamFriends, nAppID: AppId_t, eFlag: EOverlayToStoreFlag) #foreign steam "SteamAPI_ISteamFriends_ActivateGameOverlayToStore";
SteamAPI_ISteamFriends_SetPlayedWith :: (self: *ISteamFriends, steamIDUserPlayedWith: uint64_steamid) #foreign steam "SteamAPI_ISteamFriends_SetPlayedWith";
SteamAPI_ISteamFriends_ActivateGameOverlayInviteDialog :: (self: *ISteamFriends, steamIDLobby: uint64_steamid) #foreign steam "SteamAPI_ISteamFriends_ActivateGameOverlayInviteDialog";
SteamAPI_ISteamFriends_GetSmallFriendAvatar :: (self: *ISteamFriends, steamIDFriend: uint64_steamid) -> s32 #foreign steam "SteamAPI_ISteamFriends_GetSmallFriendAvatar";
SteamAPI_ISteamFriends_GetMediumFriendAvatar :: (self: *ISteamFriends, steamIDFriend: uint64_steamid) -> s32 #foreign steam "SteamAPI_ISteamFriends_GetMediumFriendAvatar";
SteamAPI_ISteamFriends_GetLargeFriendAvatar :: (self: *ISteamFriends, steamIDFriend: uint64_steamid) -> s32 #foreign steam "SteamAPI_ISteamFriends_GetLargeFriendAvatar";
SteamAPI_ISteamFriends_RequestUserInformation :: (self: *ISteamFriends, steamIDUser: uint64_steamid, bRequireNameOnly: bool) -> bool #foreign steam "SteamAPI_ISteamFriends_RequestUserInformation";
SteamAPI_ISteamFriends_RequestClanOfficerList :: (self: *ISteamFriends, steamIDClan: uint64_steamid) -> SteamAPICall_t #must #foreign steam "SteamAPI_ISteamFriends_RequestClanOfficerList";
SteamAPI_ISteamFriends_GetClanOwner :: (self: *ISteamFriends, steamIDClan: uint64_steamid) -> uint64_steamid #foreign steam "SteamAPI_ISteamFriends_GetClanOwner";
SteamAPI_ISteamFriends_GetClanOfficerCount :: (self: *ISteamFriends, steamIDClan: uint64_steamid) -> s32 #foreign steam "SteamAPI_ISteamFriends_GetClanOfficerCount";
SteamAPI_ISteamFriends_GetClanOfficerByIndex :: (self: *ISteamFriends, steamIDClan: uint64_steamid, iOfficer: s32) -> uint64_steamid #foreign steam "SteamAPI_ISteamFriends_GetClanOfficerByIndex";
SteamAPI_ISteamFriends_GetUserRestrictions :: (self: *ISteamFriends) -> uint32 #foreign steam "SteamAPI_ISteamFriends_GetUserRestrictions";
SteamAPI_ISteamFriends_SetRichPresence :: (self: *ISteamFriends, pchKey: *char, pchValue: *char) -> bool #foreign steam "SteamAPI_ISteamFriends_SetRichPresence";
SteamAPI_ISteamFriends_ClearRichPresence :: (self: *ISteamFriends) #foreign steam "SteamAPI_ISteamFriends_ClearRichPresence";
SteamAPI_ISteamFriends_GetFriendRichPresence :: (self: *ISteamFriends, steamIDFriend: uint64_steamid, pchKey: *char) -> *char #foreign steam "SteamAPI_ISteamFriends_GetFriendRichPresence";
SteamAPI_ISteamFriends_GetFriendRichPresenceKeyCount :: (self: *ISteamFriends, steamIDFriend: uint64_steamid) -> s32 #foreign steam "SteamAPI_ISteamFriends_GetFriendRichPresenceKeyCount";
SteamAPI_ISteamFriends_GetFriendRichPresenceKeyByIndex :: (self: *ISteamFriends, steamIDFriend: uint64_steamid, iKey: s32) -> *char #foreign steam "SteamAPI_ISteamFriends_GetFriendRichPresenceKeyByIndex";
SteamAPI_ISteamFriends_RequestFriendRichPresence :: (self: *ISteamFriends, steamIDFriend: uint64_steamid) #foreign steam "SteamAPI_ISteamFriends_RequestFriendRichPresence";
SteamAPI_ISteamFriends_InviteUserToGame :: (self: *ISteamFriends, steamIDFriend: uint64_steamid, pchConnectString: *char) -> bool #foreign steam "SteamAPI_ISteamFriends_InviteUserToGame";
SteamAPI_ISteamFriends_GetCoplayFriendCount :: (self: *ISteamFriends) -> s32 #foreign steam "SteamAPI_ISteamFriends_GetCoplayFriendCount";
SteamAPI_ISteamFriends_GetCoplayFriend :: (self: *ISteamFriends, iCoplayFriend: s32) -> uint64_steamid #foreign steam "SteamAPI_ISteamFriends_GetCoplayFriend";
SteamAPI_ISteamFriends_GetFriendCoplayTime :: (self: *ISteamFriends, steamIDFriend: uint64_steamid) -> s32 #foreign steam "SteamAPI_ISteamFriends_GetFriendCoplayTime";
SteamAPI_ISteamFriends_GetFriendCoplayGame :: (self: *ISteamFriends, steamIDFriend: uint64_steamid) -> AppId_t #foreign steam "SteamAPI_ISteamFriends_GetFriendCoplayGame";
SteamAPI_ISteamFriends_JoinClanChatRoom :: (self: *ISteamFriends, steamIDClan: uint64_steamid) -> SteamAPICall_t #must #foreign steam "SteamAPI_ISteamFriends_JoinClanChatRoom";
SteamAPI_ISteamFriends_LeaveClanChatRoom :: (self: *ISteamFriends, steamIDClan: uint64_steamid) -> bool #foreign steam "SteamAPI_ISteamFriends_LeaveClanChatRoom";
SteamAPI_ISteamFriends_GetClanChatMemberCount :: (self: *ISteamFriends, steamIDClan: uint64_steamid) -> s32 #foreign steam "SteamAPI_ISteamFriends_GetClanChatMemberCount";
SteamAPI_ISteamFriends_GetChatMemberByIndex :: (self: *ISteamFriends, steamIDClan: uint64_steamid, iUser: s32) -> uint64_steamid #foreign steam "SteamAPI_ISteamFriends_GetChatMemberByIndex";
SteamAPI_ISteamFriends_SendClanChatMessage :: (self: *ISteamFriends, steamIDClanChat: uint64_steamid, pchText: *char) -> bool #foreign steam "SteamAPI_ISteamFriends_SendClanChatMessage";
SteamAPI_ISteamFriends_GetClanChatMessage :: (self: *ISteamFriends, steamIDClanChat: uint64_steamid, iMessage: s32, prgchText: *void, cchTextMax: s32, peChatEntryType: *EChatEntryType, psteamidChatter: *CSteamID) -> s32 #foreign steam "SteamAPI_ISteamFriends_GetClanChatMessage";
SteamAPI_ISteamFriends_IsClanChatAdmin :: (self: *ISteamFriends, steamIDClanChat: uint64_steamid, steamIDUser: uint64_steamid) -> bool #foreign steam "SteamAPI_ISteamFriends_IsClanChatAdmin";
SteamAPI_ISteamFriends_IsClanChatWindowOpenInSteam :: (self: *ISteamFriends, steamIDClanChat: uint64_steamid) -> bool #foreign steam "SteamAPI_ISteamFriends_IsClanChatWindowOpenInSteam";
SteamAPI_ISteamFriends_OpenClanChatWindowInSteam :: (self: *ISteamFriends, steamIDClanChat: uint64_steamid) -> bool #foreign steam "SteamAPI_ISteamFriends_OpenClanChatWindowInSteam";
SteamAPI_ISteamFriends_CloseClanChatWindowInSteam :: (self: *ISteamFriends, steamIDClanChat: uint64_steamid) -> bool #foreign steam "SteamAPI_ISteamFriends_CloseClanChatWindowInSteam";
SteamAPI_ISteamFriends_SetListenForFriendsMessages :: (self: *ISteamFriends, bInterceptEnabled: bool) -> bool #foreign steam "SteamAPI_ISteamFriends_SetListenForFriendsMessages";
SteamAPI_ISteamFriends_ReplyToFriendMessage :: (self: *ISteamFriends, steamIDFriend: uint64_steamid, pchMsgToSend: *char) -> bool #foreign steam "SteamAPI_ISteamFriends_ReplyToFriendMessage";
SteamAPI_ISteamFriends_GetFriendMessage :: (self: *ISteamFriends, steamIDFriend: uint64_steamid, iMessageID: s32, pvData: *void, cubData: s32, peChatEntryType: *EChatEntryType) -> s32 #foreign steam "SteamAPI_ISteamFriends_GetFriendMessage";
SteamAPI_ISteamFriends_GetFollowerCount :: (self: *ISteamFriends, steamID: uint64_steamid) -> SteamAPICall_t #must #foreign steam "SteamAPI_ISteamFriends_GetFollowerCount";
SteamAPI_ISteamFriends_IsFollowing :: (self: *ISteamFriends, steamID: uint64_steamid) -> SteamAPICall_t #must #foreign steam "SteamAPI_ISteamFriends_IsFollowing";
SteamAPI_ISteamFriends_EnumerateFollowingList :: (self: *ISteamFriends, unStartIndex: uint32) -> SteamAPICall_t #must #foreign steam "SteamAPI_ISteamFriends_EnumerateFollowingList";
SteamAPI_ISteamFriends_IsClanPublic :: (self: *ISteamFriends, steamIDClan: uint64_steamid) -> bool #foreign steam "SteamAPI_ISteamFriends_IsClanPublic";
SteamAPI_ISteamFriends_IsClanOfficialGameGroup :: (self: *ISteamFriends, steamIDClan: uint64_steamid) -> bool #foreign steam "SteamAPI_ISteamFriends_IsClanOfficialGameGroup";
SteamAPI_ISteamFriends_GetNumChatsWithUnreadPriorityMessages :: (self: *ISteamFriends) -> s32 #foreign steam "SteamAPI_ISteamFriends_GetNumChatsWithUnreadPriorityMessages";
SteamAPI_ISteamFriends_ActivateGameOverlayRemotePlayTogetherInviteDialog :: (self: *ISteamFriends, steamIDLobby: uint64_steamid) #foreign steam "SteamAPI_ISteamFriends_ActivateGameOverlayRemotePlayTogetherInviteDialog";
SteamAPI_ISteamFriends_RegisterProtocolInOverlayBrowser :: (self: *ISteamFriends, pchProtocol: *char) -> bool #foreign steam "SteamAPI_ISteamFriends_RegisterProtocolInOverlayBrowser";
SteamAPI_ISteamFriends_ActivateGameOverlayInviteDialogConnectString :: (self: *ISteamFriends, pchConnectString: *char) #foreign steam "SteamAPI_ISteamFriends_ActivateGameOverlayInviteDialogConnectString";

// ISteamUtils
SteamAPI_SteamUtils_v010 :: () -> *ISteamUtils #foreign steam "SteamAPI_SteamUtils_v010";
SteamAPI_SteamGameServerUtils_v010 :: () -> *ISteamUtils #foreign steam "SteamAPI_SteamGameServerUtils_v010";
SteamAPI_ISteamUtils_GetSecondsSinceAppActive :: (self: *ISteamUtils) -> uint32 #foreign steam "SteamAPI_ISteamUtils_GetSecondsSinceAppActive";
SteamAPI_ISteamUtils_GetSecondsSinceComputerActive :: (self: *ISteamUtils) -> uint32 #foreign steam "SteamAPI_ISteamUtils_GetSecondsSinceComputerActive";
SteamAPI_ISteamUtils_GetConnectedUniverse :: (self: *ISteamUtils) -> EUniverse #foreign steam "SteamAPI_ISteamUtils_GetConnectedUniverse";
SteamAPI_ISteamUtils_GetServerRealTime :: (self: *ISteamUtils) -> uint32 #foreign steam "SteamAPI_ISteamUtils_GetServerRealTime";
SteamAPI_ISteamUtils_GetIPCountry :: (self: *ISteamUtils) -> *char #foreign steam "SteamAPI_ISteamUtils_GetIPCountry";
SteamAPI_ISteamUtils_GetImageSize :: (self: *ISteamUtils, iImage: s32, pnWidth: *uint32, pnHeight: *uint32) -> bool #foreign steam "SteamAPI_ISteamUtils_GetImageSize";
SteamAPI_ISteamUtils_GetImageRGBA :: (self: *ISteamUtils, iImage: s32, pubDest: *uint8, nDestBufferSize: s32) -> bool #foreign steam "SteamAPI_ISteamUtils_GetImageRGBA";
SteamAPI_ISteamUtils_GetCurrentBatteryPower :: (self: *ISteamUtils) -> uint8 #foreign steam "SteamAPI_ISteamUtils_GetCurrentBatteryPower";
SteamAPI_ISteamUtils_GetAppID :: (self: *ISteamUtils) -> uint32 #foreign steam "SteamAPI_ISteamUtils_GetAppID";
SteamAPI_ISteamUtils_SetOverlayNotificationPosition :: (self: *ISteamUtils, eNotificationPosition: ENotificationPosition) #foreign steam "SteamAPI_ISteamUtils_SetOverlayNotificationPosition";
SteamAPI_ISteamUtils_IsAPICallCompleted :: (self: *ISteamUtils, hSteamAPICall: SteamAPICall_t, pbFailed: *bool) -> bool #foreign steam "SteamAPI_ISteamUtils_IsAPICallCompleted";
SteamAPI_ISteamUtils_GetAPICallFailureReason :: (self: *ISteamUtils, hSteamAPICall: SteamAPICall_t) -> ESteamAPICallFailure #foreign steam "SteamAPI_ISteamUtils_GetAPICallFailureReason";
SteamAPI_ISteamUtils_GetAPICallResult :: (self: *ISteamUtils, hSteamAPICall: SteamAPICall_t, pCallback: *void, cubCallback: s32, iCallbackExpected: s32, pbFailed: *bool) -> bool #foreign steam "SteamAPI_ISteamUtils_GetAPICallResult";
SteamAPI_ISteamUtils_GetIPCCallCount :: (self: *ISteamUtils) -> uint32 #foreign steam "SteamAPI_ISteamUtils_GetIPCCallCount";
SteamAPI_ISteamUtils_SetWarningMessageHook :: (self: *ISteamUtils, pFunction: SteamAPIWarningMessageHook_t) #foreign steam "SteamAPI_ISteamUtils_SetWarningMessageHook";
SteamAPI_ISteamUtils_IsOverlayEnabled :: (self: *ISteamUtils) -> bool #foreign steam "SteamAPI_ISteamUtils_IsOverlayEnabled";
SteamAPI_ISteamUtils_BOverlayNeedsPresent :: (self: *ISteamUtils) -> bool #foreign steam "SteamAPI_ISteamUtils_BOverlayNeedsPresent";
SteamAPI_ISteamUtils_CheckFileSignature :: (self: *ISteamUtils, szFileName: *char) -> SteamAPICall_t #must #foreign steam "SteamAPI_ISteamUtils_CheckFileSignature";
SteamAPI_ISteamUtils_ShowGamepadTextInput :: (self: *ISteamUtils, eInputMode: EGamepadTextInputMode, eLineInputMode: EGamepadTextInputLineMode, pchDescription: *char, unCharMax: uint32, pchExistingText: *char) -> bool #foreign steam "SteamAPI_ISteamUtils_ShowGamepadTextInput";
SteamAPI_ISteamUtils_GetEnteredGamepadTextLength :: (self: *ISteamUtils) -> uint32 #foreign steam "SteamAPI_ISteamUtils_GetEnteredGamepadTextLength";
SteamAPI_ISteamUtils_GetEnteredGamepadTextInput :: (self: *ISteamUtils, pchText: *char, cchText: uint32) -> bool #foreign steam "SteamAPI_ISteamUtils_GetEnteredGamepadTextInput";
SteamAPI_ISteamUtils_GetSteamUILanguage :: (self: *ISteamUtils) -> *char #foreign steam "SteamAPI_ISteamUtils_GetSteamUILanguage";
SteamAPI_ISteamUtils_IsSteamRunningInVR :: (self: *ISteamUtils) -> bool #foreign steam "SteamAPI_ISteamUtils_IsSteamRunningInVR";
SteamAPI_ISteamUtils_SetOverlayNotificationInset :: (self: *ISteamUtils, nHorizontalInset: s32, nVerticalInset: s32) #foreign steam "SteamAPI_ISteamUtils_SetOverlayNotificationInset";
SteamAPI_ISteamUtils_IsSteamInBigPictureMode :: (self: *ISteamUtils) -> bool #foreign steam "SteamAPI_ISteamUtils_IsSteamInBigPictureMode";
SteamAPI_ISteamUtils_StartVRDashboard :: (self: *ISteamUtils) #foreign steam "SteamAPI_ISteamUtils_StartVRDashboard";
SteamAPI_ISteamUtils_IsVRHeadsetStreamingEnabled :: (self: *ISteamUtils) -> bool #foreign steam "SteamAPI_ISteamUtils_IsVRHeadsetStreamingEnabled";
SteamAPI_ISteamUtils_SetVRHeadsetStreamingEnabled :: (self: *ISteamUtils, bEnabled: bool) #foreign steam "SteamAPI_ISteamUtils_SetVRHeadsetStreamingEnabled";
SteamAPI_ISteamUtils_IsSteamChinaLauncher :: (self: *ISteamUtils) -> bool #foreign steam "SteamAPI_ISteamUtils_IsSteamChinaLauncher";
SteamAPI_ISteamUtils_InitFilterText :: (self: *ISteamUtils, unFilterOptions: uint32) -> bool #foreign steam "SteamAPI_ISteamUtils_InitFilterText";
SteamAPI_ISteamUtils_FilterText :: (self: *ISteamUtils, eContext: ETextFilteringContext, sourceSteamID: uint64_steamid, pchInputMessage: *char, pchOutFilteredText: *char, nByteSizeOutFilteredText: uint32) -> s32 #foreign steam "SteamAPI_ISteamUtils_FilterText";
SteamAPI_ISteamUtils_GetIPv6ConnectivityState :: (self: *ISteamUtils, eProtocol: ESteamIPv6ConnectivityProtocol) -> ESteamIPv6ConnectivityState #foreign steam "SteamAPI_ISteamUtils_GetIPv6ConnectivityState";

// ISteamMatchmaking
SteamAPI_SteamMatchmaking_v009 :: () -> *ISteamMatchmaking #foreign steam "SteamAPI_SteamMatchmaking_v009";
SteamAPI_ISteamMatchmaking_GetFavoriteGameCount :: (self: *ISteamMatchmaking) -> s32 #foreign steam "SteamAPI_ISteamMatchmaking_GetFavoriteGameCount";
SteamAPI_ISteamMatchmaking_GetFavoriteGame :: (self: *ISteamMatchmaking, iGame: s32, pnAppID: *AppId_t, pnIP: *uint32, pnConnPort: *uint16, pnQueryPort: *uint16, punFlags: *uint32, pRTime32LastPlayedOnServer: *uint32) -> bool #foreign steam "SteamAPI_ISteamMatchmaking_GetFavoriteGame";
SteamAPI_ISteamMatchmaking_AddFavoriteGame :: (self: *ISteamMatchmaking, nAppID: AppId_t, nIP: uint32, nConnPort: uint16, nQueryPort: uint16, unFlags: uint32, rTime32LastPlayedOnServer: uint32) -> s32 #foreign steam "SteamAPI_ISteamMatchmaking_AddFavoriteGame";
SteamAPI_ISteamMatchmaking_RemoveFavoriteGame :: (self: *ISteamMatchmaking, nAppID: AppId_t, nIP: uint32, nConnPort: uint16, nQueryPort: uint16, unFlags: uint32) -> bool #foreign steam "SteamAPI_ISteamMatchmaking_RemoveFavoriteGame";
SteamAPI_ISteamMatchmaking_RequestLobbyList :: (self: *ISteamMatchmaking) -> SteamAPICall_t #must #foreign steam "SteamAPI_ISteamMatchmaking_RequestLobbyList";
SteamAPI_ISteamMatchmaking_AddRequestLobbyListStringFilter :: (self: *ISteamMatchmaking, pchKeyToMatch: *char, pchValueToMatch: *char, eComparisonType: ELobbyComparison) #foreign steam "SteamAPI_ISteamMatchmaking_AddRequestLobbyListStringFilter";
SteamAPI_ISteamMatchmaking_AddRequestLobbyListNumericalFilter :: (self: *ISteamMatchmaking, pchKeyToMatch: *char, nValueToMatch: s32, eComparisonType: ELobbyComparison) #foreign steam "SteamAPI_ISteamMatchmaking_AddRequestLobbyListNumericalFilter";
SteamAPI_ISteamMatchmaking_AddRequestLobbyListNearValueFilter :: (self: *ISteamMatchmaking, pchKeyToMatch: *char, nValueToBeCloseTo: s32) #foreign steam "SteamAPI_ISteamMatchmaking_AddRequestLobbyListNearValueFilter";
SteamAPI_ISteamMatchmaking_AddRequestLobbyListFilterSlotsAvailable :: (self: *ISteamMatchmaking, nSlotsAvailable: s32) #foreign steam "SteamAPI_ISteamMatchmaking_AddRequestLobbyListFilterSlotsAvailable";
SteamAPI_ISteamMatchmaking_AddRequestLobbyListDistanceFilter :: (self: *ISteamMatchmaking, eLobbyDistanceFilter: ELobbyDistanceFilter) #foreign steam "SteamAPI_ISteamMatchmaking_AddRequestLobbyListDistanceFilter";
SteamAPI_ISteamMatchmaking_AddRequestLobbyListResultCountFilter :: (self: *ISteamMatchmaking, cMaxResults: s32) #foreign steam "SteamAPI_ISteamMatchmaking_AddRequestLobbyListResultCountFilter";
SteamAPI_ISteamMatchmaking_AddRequestLobbyListCompatibleMembersFilter :: (self: *ISteamMatchmaking, steamIDLobby: uint64_steamid) #foreign steam "SteamAPI_ISteamMatchmaking_AddRequestLobbyListCompatibleMembersFilter";
SteamAPI_ISteamMatchmaking_GetLobbyByIndex :: (self: *ISteamMatchmaking, iLobby: s32) -> uint64_steamid #foreign steam "SteamAPI_ISteamMatchmaking_GetLobbyByIndex";
SteamAPI_ISteamMatchmaking_CreateLobby :: (self: *ISteamMatchmaking, eLobbyType: ELobbyType, cMaxMembers: s32) -> SteamAPICall_t #must #foreign steam "SteamAPI_ISteamMatchmaking_CreateLobby";
SteamAPI_ISteamMatchmaking_JoinLobby :: (self: *ISteamMatchmaking, steamIDLobby: uint64_steamid) -> SteamAPICall_t #must #foreign steam "SteamAPI_ISteamMatchmaking_JoinLobby";
SteamAPI_ISteamMatchmaking_LeaveLobby :: (self: *ISteamMatchmaking, steamIDLobby: uint64_steamid) #foreign steam "SteamAPI_ISteamMatchmaking_LeaveLobby";
SteamAPI_ISteamMatchmaking_InviteUserToLobby :: (self: *ISteamMatchmaking, steamIDLobby: uint64_steamid, steamIDInvitee: uint64_steamid) -> bool #foreign steam "SteamAPI_ISteamMatchmaking_InviteUserToLobby";
SteamAPI_ISteamMatchmaking_GetNumLobbyMembers :: (self: *ISteamMatchmaking, steamIDLobby: uint64_steamid) -> s32 #foreign steam "SteamAPI_ISteamMatchmaking_GetNumLobbyMembers";
SteamAPI_ISteamMatchmaking_GetLobbyMemberByIndex :: (self: *ISteamMatchmaking, steamIDLobby: uint64_steamid, iMember: s32) -> uint64_steamid #foreign steam "SteamAPI_ISteamMatchmaking_GetLobbyMemberByIndex";
SteamAPI_ISteamMatchmaking_GetLobbyData :: (self: *ISteamMatchmaking, steamIDLobby: uint64_steamid, pchKey: *char) -> *char #foreign steam "SteamAPI_ISteamMatchmaking_GetLobbyData";
SteamAPI_ISteamMatchmaking_SetLobbyData :: (self: *ISteamMatchmaking, steamIDLobby: uint64_steamid, pchKey: *char, pchValue: *char) -> bool #foreign steam "SteamAPI_ISteamMatchmaking_SetLobbyData";
SteamAPI_ISteamMatchmaking_GetLobbyDataCount :: (self: *ISteamMatchmaking, steamIDLobby: uint64_steamid) -> s32 #foreign steam "SteamAPI_ISteamMatchmaking_GetLobbyDataCount";
SteamAPI_ISteamMatchmaking_GetLobbyDataByIndex :: (self: *ISteamMatchmaking, steamIDLobby: uint64_steamid, iLobbyData: s32, pchKey: *char, cchKeyBufferSize: s32, pchValue: *char, cchValueBufferSize: s32) -> bool #foreign steam "SteamAPI_ISteamMatchmaking_GetLobbyDataByIndex";
SteamAPI_ISteamMatchmaking_DeleteLobbyData :: (self: *ISteamMatchmaking, steamIDLobby: uint64_steamid, pchKey: *char) -> bool #foreign steam "SteamAPI_ISteamMatchmaking_DeleteLobbyData";
SteamAPI_ISteamMatchmaking_GetLobbyMemberData :: (self: *ISteamMatchmaking, steamIDLobby: uint64_steamid, steamIDUser: uint64_steamid, pchKey: *char) -> *char #foreign steam "SteamAPI_ISteamMatchmaking_GetLobbyMemberData";
SteamAPI_ISteamMatchmaking_SetLobbyMemberData :: (self: *ISteamMatchmaking, steamIDLobby: uint64_steamid, pchKey: *char, pchValue: *char) #foreign steam "SteamAPI_ISteamMatchmaking_SetLobbyMemberData";
SteamAPI_ISteamMatchmaking_SendLobbyChatMsg :: (self: *ISteamMatchmaking, steamIDLobby: uint64_steamid, pvMsgBody: *void, cubMsgBody: s32) -> bool #foreign steam "SteamAPI_ISteamMatchmaking_SendLobbyChatMsg";
SteamAPI_ISteamMatchmaking_GetLobbyChatEntry :: (self: *ISteamMatchmaking, steamIDLobby: uint64_steamid, iChatID: s32, pSteamIDUser: *CSteamID, pvData: *void, cubData: s32, peChatEntryType: *EChatEntryType) -> s32 #foreign steam "SteamAPI_ISteamMatchmaking_GetLobbyChatEntry";
SteamAPI_ISteamMatchmaking_RequestLobbyData :: (self: *ISteamMatchmaking, steamIDLobby: uint64_steamid) -> bool #foreign steam "SteamAPI_ISteamMatchmaking_RequestLobbyData";
SteamAPI_ISteamMatchmaking_SetLobbyGameServer :: (self: *ISteamMatchmaking, steamIDLobby: uint64_steamid, unGameServerIP: uint32, unGameServerPort: uint16, steamIDGameServer: uint64_steamid) #foreign steam "SteamAPI_ISteamMatchmaking_SetLobbyGameServer";
SteamAPI_ISteamMatchmaking_GetLobbyGameServer :: (self: *ISteamMatchmaking, steamIDLobby: uint64_steamid, punGameServerIP: *uint32, punGameServerPort: *uint16, psteamIDGameServer: *CSteamID) -> bool #foreign steam "SteamAPI_ISteamMatchmaking_GetLobbyGameServer";
SteamAPI_ISteamMatchmaking_SetLobbyMemberLimit :: (self: *ISteamMatchmaking, steamIDLobby: uint64_steamid, cMaxMembers: s32) -> bool #foreign steam "SteamAPI_ISteamMatchmaking_SetLobbyMemberLimit";
SteamAPI_ISteamMatchmaking_GetLobbyMemberLimit :: (self: *ISteamMatchmaking, steamIDLobby: uint64_steamid) -> s32 #foreign steam "SteamAPI_ISteamMatchmaking_GetLobbyMemberLimit";
SteamAPI_ISteamMatchmaking_SetLobbyType :: (self: *ISteamMatchmaking, steamIDLobby: uint64_steamid, eLobbyType: ELobbyType) -> bool #foreign steam "SteamAPI_ISteamMatchmaking_SetLobbyType";
SteamAPI_ISteamMatchmaking_SetLobbyJoinable :: (self: *ISteamMatchmaking, steamIDLobby: uint64_steamid, bLobbyJoinable: bool) -> bool #foreign steam "SteamAPI_ISteamMatchmaking_SetLobbyJoinable";
SteamAPI_ISteamMatchmaking_GetLobbyOwner :: (self: *ISteamMatchmaking, steamIDLobby: uint64_steamid) -> uint64_steamid #foreign steam "SteamAPI_ISteamMatchmaking_GetLobbyOwner";
SteamAPI_ISteamMatchmaking_SetLobbyOwner :: (self: *ISteamMatchmaking, steamIDLobby: uint64_steamid, steamIDNewOwner: uint64_steamid) -> bool #foreign steam "SteamAPI_ISteamMatchmaking_SetLobbyOwner";
SteamAPI_ISteamMatchmaking_SetLinkedLobby :: (self: *ISteamMatchmaking, steamIDLobby: uint64_steamid, steamIDLobbyDependent: uint64_steamid) -> bool #foreign steam "SteamAPI_ISteamMatchmaking_SetLinkedLobby";

// ISteamMatchmakingServerListResponse
SteamAPI_ISteamMatchmakingServerListResponse_ServerResponded :: (self: *ISteamMatchmakingServerListResponse, hRequest: HServerListRequest, iServer: s32) #foreign steam "SteamAPI_ISteamMatchmakingServerListResponse_ServerResponded";
SteamAPI_ISteamMatchmakingServerListResponse_ServerFailedToRespond :: (self: *ISteamMatchmakingServerListResponse, hRequest: HServerListRequest, iServer: s32) #foreign steam "SteamAPI_ISteamMatchmakingServerListResponse_ServerFailedToRespond";
SteamAPI_ISteamMatchmakingServerListResponse_RefreshComplete :: (self: *ISteamMatchmakingServerListResponse, hRequest: HServerListRequest, response: EMatchMakingServerResponse) #foreign steam "SteamAPI_ISteamMatchmakingServerListResponse_RefreshComplete";

// ISteamMatchmakingPingResponse
SteamAPI_ISteamMatchmakingPingResponse_ServerResponded :: (self: *ISteamMatchmakingPingResponse, server: *gameserveritem_t) #foreign steam "SteamAPI_ISteamMatchmakingPingResponse_ServerResponded";
SteamAPI_ISteamMatchmakingPingResponse_ServerFailedToRespond :: (self: *ISteamMatchmakingPingResponse) #foreign steam "SteamAPI_ISteamMatchmakingPingResponse_ServerFailedToRespond";

// ISteamMatchmakingPlayersResponse
SteamAPI_ISteamMatchmakingPlayersResponse_AddPlayerToList :: (self: *ISteamMatchmakingPlayersResponse, pchName: *char, nScore: s32, flTimePlayed: float) #foreign steam "SteamAPI_ISteamMatchmakingPlayersResponse_AddPlayerToList";
SteamAPI_ISteamMatchmakingPlayersResponse_PlayersFailedToRespond :: (self: *ISteamMatchmakingPlayersResponse) #foreign steam "SteamAPI_ISteamMatchmakingPlayersResponse_PlayersFailedToRespond";
SteamAPI_ISteamMatchmakingPlayersResponse_PlayersRefreshComplete :: (self: *ISteamMatchmakingPlayersResponse) #foreign steam "SteamAPI_ISteamMatchmakingPlayersResponse_PlayersRefreshComplete";

// ISteamMatchmakingRulesResponse
SteamAPI_ISteamMatchmakingRulesResponse_RulesResponded :: (self: *ISteamMatchmakingRulesResponse, pchRule: *char, pchValue: *char) #foreign steam "SteamAPI_ISteamMatchmakingRulesResponse_RulesResponded";
SteamAPI_ISteamMatchmakingRulesResponse_RulesFailedToRespond :: (self: *ISteamMatchmakingRulesResponse) #foreign steam "SteamAPI_ISteamMatchmakingRulesResponse_RulesFailedToRespond";
SteamAPI_ISteamMatchmakingRulesResponse_RulesRefreshComplete :: (self: *ISteamMatchmakingRulesResponse) #foreign steam "SteamAPI_ISteamMatchmakingRulesResponse_RulesRefreshComplete";

// ISteamMatchmakingServers
SteamAPI_SteamMatchmakingServers_v002 :: () -> *ISteamMatchmakingServers #foreign steam "SteamAPI_SteamMatchmakingServers_v002";
SteamAPI_ISteamMatchmakingServers_RequestInternetServerList :: (self: *ISteamMatchmakingServers, iApp: AppId_t, ppchFilters: **MatchMakingKeyValuePair_t, nFilters: uint32, pRequestServersResponse: *ISteamMatchmakingServerListResponse) -> HServerListRequest #foreign steam "SteamAPI_ISteamMatchmakingServers_RequestInternetServerList";
SteamAPI_ISteamMatchmakingServers_RequestLANServerList :: (self: *ISteamMatchmakingServers, iApp: AppId_t, pRequestServersResponse: *ISteamMatchmakingServerListResponse) -> HServerListRequest #foreign steam "SteamAPI_ISteamMatchmakingServers_RequestLANServerList";
SteamAPI_ISteamMatchmakingServers_RequestFriendsServerList :: (self: *ISteamMatchmakingServers, iApp: AppId_t, ppchFilters: **MatchMakingKeyValuePair_t, nFilters: uint32, pRequestServersResponse: *ISteamMatchmakingServerListResponse) -> HServerListRequest #foreign steam "SteamAPI_ISteamMatchmakingServers_RequestFriendsServerList";
SteamAPI_ISteamMatchmakingServers_RequestFavoritesServerList :: (self: *ISteamMatchmakingServers, iApp: AppId_t, ppchFilters: **MatchMakingKeyValuePair_t, nFilters: uint32, pRequestServersResponse: *ISteamMatchmakingServerListResponse) -> HServerListRequest #foreign steam "SteamAPI_ISteamMatchmakingServers_RequestFavoritesServerList";
SteamAPI_ISteamMatchmakingServers_RequestHistoryServerList :: (self: *ISteamMatchmakingServers, iApp: AppId_t, ppchFilters: **MatchMakingKeyValuePair_t, nFilters: uint32, pRequestServersResponse: *ISteamMatchmakingServerListResponse) -> HServerListRequest #foreign steam "SteamAPI_ISteamMatchmakingServers_RequestHistoryServerList";
SteamAPI_ISteamMatchmakingServers_RequestSpectatorServerList :: (self: *ISteamMatchmakingServers, iApp: AppId_t, ppchFilters: **MatchMakingKeyValuePair_t, nFilters: uint32, pRequestServersResponse: *ISteamMatchmakingServerListResponse) -> HServerListRequest #foreign steam "SteamAPI_ISteamMatchmakingServers_RequestSpectatorServerList";
SteamAPI_ISteamMatchmakingServers_ReleaseRequest :: (self: *ISteamMatchmakingServers, hServerListRequest: HServerListRequest) #foreign steam "SteamAPI_ISteamMatchmakingServers_ReleaseRequest";
SteamAPI_ISteamMatchmakingServers_GetServerDetails :: (self: *ISteamMatchmakingServers, hRequest: HServerListRequest, iServer: s32) -> *gameserveritem_t #foreign steam "SteamAPI_ISteamMatchmakingServers_GetServerDetails";
SteamAPI_ISteamMatchmakingServers_CancelQuery :: (self: *ISteamMatchmakingServers, hRequest: HServerListRequest) #foreign steam "SteamAPI_ISteamMatchmakingServers_CancelQuery";
SteamAPI_ISteamMatchmakingServers_RefreshQuery :: (self: *ISteamMatchmakingServers, hRequest: HServerListRequest) #foreign steam "SteamAPI_ISteamMatchmakingServers_RefreshQuery";
SteamAPI_ISteamMatchmakingServers_IsRefreshing :: (self: *ISteamMatchmakingServers, hRequest: HServerListRequest) -> bool #foreign steam "SteamAPI_ISteamMatchmakingServers_IsRefreshing";
SteamAPI_ISteamMatchmakingServers_GetServerCount :: (self: *ISteamMatchmakingServers, hRequest: HServerListRequest) -> s32 #foreign steam "SteamAPI_ISteamMatchmakingServers_GetServerCount";
SteamAPI_ISteamMatchmakingServers_RefreshServer :: (self: *ISteamMatchmakingServers, hRequest: HServerListRequest, iServer: s32) #foreign steam "SteamAPI_ISteamMatchmakingServers_RefreshServer";
SteamAPI_ISteamMatchmakingServers_PingServer :: (self: *ISteamMatchmakingServers, unIP: uint32, usPort: uint16, pRequestServersResponse: *ISteamMatchmakingPingResponse) -> HServerQuery #foreign steam "SteamAPI_ISteamMatchmakingServers_PingServer";
SteamAPI_ISteamMatchmakingServers_PlayerDetails :: (self: *ISteamMatchmakingServers, unIP: uint32, usPort: uint16, pRequestServersResponse: *ISteamMatchmakingPlayersResponse) -> HServerQuery #foreign steam "SteamAPI_ISteamMatchmakingServers_PlayerDetails";
SteamAPI_ISteamMatchmakingServers_ServerRules :: (self: *ISteamMatchmakingServers, unIP: uint32, usPort: uint16, pRequestServersResponse: *ISteamMatchmakingRulesResponse) -> HServerQuery #foreign steam "SteamAPI_ISteamMatchmakingServers_ServerRules";
SteamAPI_ISteamMatchmakingServers_CancelServerQuery :: (self: *ISteamMatchmakingServers, hServerQuery: HServerQuery) #foreign steam "SteamAPI_ISteamMatchmakingServers_CancelServerQuery";

// ISteamGameSearch
SteamAPI_SteamGameSearch_v001 :: () -> *ISteamGameSearch #foreign steam "SteamAPI_SteamGameSearch_v001";
SteamAPI_ISteamGameSearch_AddGameSearchParams :: (self: *ISteamGameSearch, pchKeyToFind: *char, pchValuesToFind: *char) -> EGameSearchErrorCode_t #foreign steam "SteamAPI_ISteamGameSearch_AddGameSearchParams";
SteamAPI_ISteamGameSearch_SearchForGameWithLobby :: (self: *ISteamGameSearch, steamIDLobby: uint64_steamid, nPlayerMin: s32, nPlayerMax: s32) -> EGameSearchErrorCode_t #foreign steam "SteamAPI_ISteamGameSearch_SearchForGameWithLobby";
SteamAPI_ISteamGameSearch_SearchForGameSolo :: (self: *ISteamGameSearch, nPlayerMin: s32, nPlayerMax: s32) -> EGameSearchErrorCode_t #foreign steam "SteamAPI_ISteamGameSearch_SearchForGameSolo";
SteamAPI_ISteamGameSearch_AcceptGame :: (self: *ISteamGameSearch) -> EGameSearchErrorCode_t #foreign steam "SteamAPI_ISteamGameSearch_AcceptGame";
SteamAPI_ISteamGameSearch_DeclineGame :: (self: *ISteamGameSearch) -> EGameSearchErrorCode_t #foreign steam "SteamAPI_ISteamGameSearch_DeclineGame";
SteamAPI_ISteamGameSearch_RetrieveConnectionDetails :: (self: *ISteamGameSearch, steamIDHost: uint64_steamid, pchConnectionDetails: *char, cubConnectionDetails: s32) -> EGameSearchErrorCode_t #foreign steam "SteamAPI_ISteamGameSearch_RetrieveConnectionDetails";
SteamAPI_ISteamGameSearch_EndGameSearch :: (self: *ISteamGameSearch) -> EGameSearchErrorCode_t #foreign steam "SteamAPI_ISteamGameSearch_EndGameSearch";
SteamAPI_ISteamGameSearch_SetGameHostParams :: (self: *ISteamGameSearch, pchKey: *char, pchValue: *char) -> EGameSearchErrorCode_t #foreign steam "SteamAPI_ISteamGameSearch_SetGameHostParams";
SteamAPI_ISteamGameSearch_SetConnectionDetails :: (self: *ISteamGameSearch, pchConnectionDetails: *char, cubConnectionDetails: s32) -> EGameSearchErrorCode_t #foreign steam "SteamAPI_ISteamGameSearch_SetConnectionDetails";
SteamAPI_ISteamGameSearch_RequestPlayersForGame :: (self: *ISteamGameSearch, nPlayerMin: s32, nPlayerMax: s32, nMaxTeamSize: s32) -> EGameSearchErrorCode_t #foreign steam "SteamAPI_ISteamGameSearch_RequestPlayersForGame";
SteamAPI_ISteamGameSearch_HostConfirmGameStart :: (self: *ISteamGameSearch, ullUniqueGameID: uint64) -> EGameSearchErrorCode_t #foreign steam "SteamAPI_ISteamGameSearch_HostConfirmGameStart";
SteamAPI_ISteamGameSearch_CancelRequestPlayersForGame :: (self: *ISteamGameSearch) -> EGameSearchErrorCode_t #foreign steam "SteamAPI_ISteamGameSearch_CancelRequestPlayersForGame";
SteamAPI_ISteamGameSearch_SubmitPlayerResult :: (self: *ISteamGameSearch, ullUniqueGameID: uint64, steamIDPlayer: uint64_steamid, EPlayerResult: EPlayerResult_t) -> EGameSearchErrorCode_t #foreign steam "SteamAPI_ISteamGameSearch_SubmitPlayerResult";
SteamAPI_ISteamGameSearch_EndGame :: (self: *ISteamGameSearch, ullUniqueGameID: uint64) -> EGameSearchErrorCode_t #foreign steam "SteamAPI_ISteamGameSearch_EndGame";

// ISteamParties
SteamAPI_SteamParties_v002 :: () -> *ISteamParties #foreign steam "SteamAPI_SteamParties_v002";
SteamAPI_ISteamParties_GetNumActiveBeacons :: (self: *ISteamParties) -> uint32 #foreign steam "SteamAPI_ISteamParties_GetNumActiveBeacons";
SteamAPI_ISteamParties_GetBeaconByIndex :: (self: *ISteamParties, unIndex: uint32) -> PartyBeaconID_t #foreign steam "SteamAPI_ISteamParties_GetBeaconByIndex";
SteamAPI_ISteamParties_GetBeaconDetails :: (self: *ISteamParties, ulBeaconID: PartyBeaconID_t, pSteamIDBeaconOwner: *CSteamID, pLocation: *SteamPartyBeaconLocation_t, pchMetadata: *char, cchMetadata: s32) -> bool #foreign steam "SteamAPI_ISteamParties_GetBeaconDetails";
SteamAPI_ISteamParties_JoinParty :: (self: *ISteamParties, ulBeaconID: PartyBeaconID_t) -> SteamAPICall_t #must #foreign steam "SteamAPI_ISteamParties_JoinParty";
SteamAPI_ISteamParties_GetNumAvailableBeaconLocations :: (self: *ISteamParties, puNumLocations: *uint32) -> bool #foreign steam "SteamAPI_ISteamParties_GetNumAvailableBeaconLocations";
SteamAPI_ISteamParties_GetAvailableBeaconLocations :: (self: *ISteamParties, pLocationList: *SteamPartyBeaconLocation_t, uMaxNumLocations: uint32) -> bool #foreign steam "SteamAPI_ISteamParties_GetAvailableBeaconLocations";
SteamAPI_ISteamParties_CreateBeacon :: (self: *ISteamParties, unOpenSlots: uint32, pBeaconLocation: *SteamPartyBeaconLocation_t, pchConnectString: *char, pchMetadata: *char) -> SteamAPICall_t #must #foreign steam "SteamAPI_ISteamParties_CreateBeacon";
SteamAPI_ISteamParties_OnReservationCompleted :: (self: *ISteamParties, ulBeacon: PartyBeaconID_t, steamIDUser: uint64_steamid) #foreign steam "SteamAPI_ISteamParties_OnReservationCompleted";
SteamAPI_ISteamParties_CancelReservation :: (self: *ISteamParties, ulBeacon: PartyBeaconID_t, steamIDUser: uint64_steamid) #foreign steam "SteamAPI_ISteamParties_CancelReservation";
SteamAPI_ISteamParties_ChangeNumOpenSlots :: (self: *ISteamParties, ulBeacon: PartyBeaconID_t, unOpenSlots: uint32) -> SteamAPICall_t #must #foreign steam "SteamAPI_ISteamParties_ChangeNumOpenSlots";
SteamAPI_ISteamParties_DestroyBeacon :: (self: *ISteamParties, ulBeacon: PartyBeaconID_t) -> bool #foreign steam "SteamAPI_ISteamParties_DestroyBeacon";
SteamAPI_ISteamParties_GetBeaconLocationData :: (self: *ISteamParties, BeaconLocation: SteamPartyBeaconLocation_t, eData: ESteamPartyBeaconLocationData, pchDataStringOut: *char, cchDataStringOut: s32) -> bool #foreign steam "SteamAPI_ISteamParties_GetBeaconLocationData";

// ISteamRemoteStorage
SteamAPI_SteamRemoteStorage_v014 :: () -> *ISteamRemoteStorage #foreign steam "SteamAPI_SteamRemoteStorage_v014";
SteamAPI_ISteamRemoteStorage_FileWrite :: (self: *ISteamRemoteStorage, pchFile: *char, pvData: *void, cubData: int32) -> bool #foreign steam "SteamAPI_ISteamRemoteStorage_FileWrite";
SteamAPI_ISteamRemoteStorage_FileRead :: (self: *ISteamRemoteStorage, pchFile: *char, pvData: *void, cubDataToRead: int32) -> int32 #foreign steam "SteamAPI_ISteamRemoteStorage_FileRead";
SteamAPI_ISteamRemoteStorage_FileWriteAsync :: (self: *ISteamRemoteStorage, pchFile: *char, pvData: *void, cubData: uint32) -> SteamAPICall_t #must #foreign steam "SteamAPI_ISteamRemoteStorage_FileWriteAsync";
SteamAPI_ISteamRemoteStorage_FileReadAsync :: (self: *ISteamRemoteStorage, pchFile: *char, nOffset: uint32, cubToRead: uint32) -> SteamAPICall_t #must #foreign steam "SteamAPI_ISteamRemoteStorage_FileReadAsync";
SteamAPI_ISteamRemoteStorage_FileReadAsyncComplete :: (self: *ISteamRemoteStorage, hReadCall: SteamAPICall_t, pvBuffer: *void, cubToRead: uint32) -> bool #foreign steam "SteamAPI_ISteamRemoteStorage_FileReadAsyncComplete";
SteamAPI_ISteamRemoteStorage_FileForget :: (self: *ISteamRemoteStorage, pchFile: *char) -> bool #foreign steam "SteamAPI_ISteamRemoteStorage_FileForget";
SteamAPI_ISteamRemoteStorage_FileDelete :: (self: *ISteamRemoteStorage, pchFile: *char) -> bool #foreign steam "SteamAPI_ISteamRemoteStorage_FileDelete";
SteamAPI_ISteamRemoteStorage_FileShare :: (self: *ISteamRemoteStorage, pchFile: *char) -> SteamAPICall_t #must #foreign steam "SteamAPI_ISteamRemoteStorage_FileShare";
SteamAPI_ISteamRemoteStorage_SetSyncPlatforms :: (self: *ISteamRemoteStorage, pchFile: *char, eRemoteStoragePlatform: ERemoteStoragePlatform) -> bool #foreign steam "SteamAPI_ISteamRemoteStorage_SetSyncPlatforms";
SteamAPI_ISteamRemoteStorage_FileWriteStreamOpen :: (self: *ISteamRemoteStorage, pchFile: *char) -> UGCFileWriteStreamHandle_t #foreign steam "SteamAPI_ISteamRemoteStorage_FileWriteStreamOpen";
SteamAPI_ISteamRemoteStorage_FileWriteStreamWriteChunk :: (self: *ISteamRemoteStorage, writeHandle: UGCFileWriteStreamHandle_t, pvData: *void, cubData: int32) -> bool #foreign steam "SteamAPI_ISteamRemoteStorage_FileWriteStreamWriteChunk";
SteamAPI_ISteamRemoteStorage_FileWriteStreamClose :: (self: *ISteamRemoteStorage, writeHandle: UGCFileWriteStreamHandle_t) -> bool #foreign steam "SteamAPI_ISteamRemoteStorage_FileWriteStreamClose";
SteamAPI_ISteamRemoteStorage_FileWriteStreamCancel :: (self: *ISteamRemoteStorage, writeHandle: UGCFileWriteStreamHandle_t) -> bool #foreign steam "SteamAPI_ISteamRemoteStorage_FileWriteStreamCancel";
SteamAPI_ISteamRemoteStorage_FileExists :: (self: *ISteamRemoteStorage, pchFile: *char) -> bool #foreign steam "SteamAPI_ISteamRemoteStorage_FileExists";
SteamAPI_ISteamRemoteStorage_FilePersisted :: (self: *ISteamRemoteStorage, pchFile: *char) -> bool #foreign steam "SteamAPI_ISteamRemoteStorage_FilePersisted";
SteamAPI_ISteamRemoteStorage_GetFileSize :: (self: *ISteamRemoteStorage, pchFile: *char) -> int32 #foreign steam "SteamAPI_ISteamRemoteStorage_GetFileSize";
SteamAPI_ISteamRemoteStorage_GetFileTimestamp :: (self: *ISteamRemoteStorage, pchFile: *char) -> int64 #foreign steam "SteamAPI_ISteamRemoteStorage_GetFileTimestamp";
SteamAPI_ISteamRemoteStorage_GetSyncPlatforms :: (self: *ISteamRemoteStorage, pchFile: *char) -> ERemoteStoragePlatform #foreign steam "SteamAPI_ISteamRemoteStorage_GetSyncPlatforms";
SteamAPI_ISteamRemoteStorage_GetFileCount :: (self: *ISteamRemoteStorage) -> int32 #foreign steam "SteamAPI_ISteamRemoteStorage_GetFileCount";
SteamAPI_ISteamRemoteStorage_GetFileNameAndSize :: (self: *ISteamRemoteStorage, iFile: s32, pnFileSizeInBytes: *int32) -> *char #foreign steam "SteamAPI_ISteamRemoteStorage_GetFileNameAndSize";
SteamAPI_ISteamRemoteStorage_GetQuota :: (self: *ISteamRemoteStorage, pnTotalBytes: *uint64, puAvailableBytes: *uint64) -> bool #foreign steam "SteamAPI_ISteamRemoteStorage_GetQuota";
SteamAPI_ISteamRemoteStorage_IsCloudEnabledForAccount :: (self: *ISteamRemoteStorage) -> bool #foreign steam "SteamAPI_ISteamRemoteStorage_IsCloudEnabledForAccount";
SteamAPI_ISteamRemoteStorage_IsCloudEnabledForApp :: (self: *ISteamRemoteStorage) -> bool #foreign steam "SteamAPI_ISteamRemoteStorage_IsCloudEnabledForApp";
SteamAPI_ISteamRemoteStorage_SetCloudEnabledForApp :: (self: *ISteamRemoteStorage, bEnabled: bool) #foreign steam "SteamAPI_ISteamRemoteStorage_SetCloudEnabledForApp";
SteamAPI_ISteamRemoteStorage_UGCDownload :: (self: *ISteamRemoteStorage, hContent: UGCHandle_t, unPriority: uint32) -> SteamAPICall_t #must #foreign steam "SteamAPI_ISteamRemoteStorage_UGCDownload";
SteamAPI_ISteamRemoteStorage_GetUGCDownloadProgress :: (self: *ISteamRemoteStorage, hContent: UGCHandle_t, pnBytesDownloaded: *int32, pnBytesExpected: *int32) -> bool #foreign steam "SteamAPI_ISteamRemoteStorage_GetUGCDownloadProgress";
SteamAPI_ISteamRemoteStorage_GetUGCDetails :: (self: *ISteamRemoteStorage, hContent: UGCHandle_t, pnAppID: *AppId_t, ppchName: **char, pnFileSizeInBytes: *int32, pSteamIDOwner: *CSteamID) -> bool #foreign steam "SteamAPI_ISteamRemoteStorage_GetUGCDetails";
SteamAPI_ISteamRemoteStorage_UGCRead :: (self: *ISteamRemoteStorage, hContent: UGCHandle_t, pvData: *void, cubDataToRead: int32, cOffset: uint32, eAction: EUGCReadAction) -> int32 #foreign steam "SteamAPI_ISteamRemoteStorage_UGCRead";
SteamAPI_ISteamRemoteStorage_GetCachedUGCCount :: (self: *ISteamRemoteStorage) -> int32 #foreign steam "SteamAPI_ISteamRemoteStorage_GetCachedUGCCount";
SteamAPI_ISteamRemoteStorage_GetCachedUGCHandle :: (self: *ISteamRemoteStorage, iCachedContent: int32) -> UGCHandle_t #foreign steam "SteamAPI_ISteamRemoteStorage_GetCachedUGCHandle";
SteamAPI_ISteamRemoteStorage_PublishWorkshopFile :: (self: *ISteamRemoteStorage, pchFile: *char, pchPreviewFile: *char, nConsumerAppId: AppId_t, pchTitle: *char, pchDescription: *char, eVisibility: ERemoteStoragePublishedFileVisibility, pTags: *SteamParamStringArray_t, eWorkshopFileType: EWorkshopFileType) -> SteamAPICall_t #must #foreign steam "SteamAPI_ISteamRemoteStorage_PublishWorkshopFile";
SteamAPI_ISteamRemoteStorage_CreatePublishedFileUpdateRequest :: (self: *ISteamRemoteStorage, unPublishedFileId: PublishedFileId_t) -> PublishedFileUpdateHandle_t #foreign steam "SteamAPI_ISteamRemoteStorage_CreatePublishedFileUpdateRequest";
SteamAPI_ISteamRemoteStorage_UpdatePublishedFileFile :: (self: *ISteamRemoteStorage, updateHandle: PublishedFileUpdateHandle_t, pchFile: *char) -> bool #foreign steam "SteamAPI_ISteamRemoteStorage_UpdatePublishedFileFile";
SteamAPI_ISteamRemoteStorage_UpdatePublishedFilePreviewFile :: (self: *ISteamRemoteStorage, updateHandle: PublishedFileUpdateHandle_t, pchPreviewFile: *char) -> bool #foreign steam "SteamAPI_ISteamRemoteStorage_UpdatePublishedFilePreviewFile";
SteamAPI_ISteamRemoteStorage_UpdatePublishedFileTitle :: (self: *ISteamRemoteStorage, updateHandle: PublishedFileUpdateHandle_t, pchTitle: *char) -> bool #foreign steam "SteamAPI_ISteamRemoteStorage_UpdatePublishedFileTitle";
SteamAPI_ISteamRemoteStorage_UpdatePublishedFileDescription :: (self: *ISteamRemoteStorage, updateHandle: PublishedFileUpdateHandle_t, pchDescription: *char) -> bool #foreign steam "SteamAPI_ISteamRemoteStorage_UpdatePublishedFileDescription";
SteamAPI_ISteamRemoteStorage_UpdatePublishedFileVisibility :: (self: *ISteamRemoteStorage, updateHandle: PublishedFileUpdateHandle_t, eVisibility: ERemoteStoragePublishedFileVisibility) -> bool #foreign steam "SteamAPI_ISteamRemoteStorage_UpdatePublishedFileVisibility";
SteamAPI_ISteamRemoteStorage_UpdatePublishedFileTags :: (self: *ISteamRemoteStorage, updateHandle: PublishedFileUpdateHandle_t, pTags: *SteamParamStringArray_t) -> bool #foreign steam "SteamAPI_ISteamRemoteStorage_UpdatePublishedFileTags";
SteamAPI_ISteamRemoteStorage_CommitPublishedFileUpdate :: (self: *ISteamRemoteStorage, updateHandle: PublishedFileUpdateHandle_t) -> SteamAPICall_t #must #foreign steam "SteamAPI_ISteamRemoteStorage_CommitPublishedFileUpdate";
SteamAPI_ISteamRemoteStorage_GetPublishedFileDetails :: (self: *ISteamRemoteStorage, unPublishedFileId: PublishedFileId_t, unMaxSecondsOld: uint32) -> SteamAPICall_t #must #foreign steam "SteamAPI_ISteamRemoteStorage_GetPublishedFileDetails";
SteamAPI_ISteamRemoteStorage_DeletePublishedFile :: (self: *ISteamRemoteStorage, unPublishedFileId: PublishedFileId_t) -> SteamAPICall_t #must #foreign steam "SteamAPI_ISteamRemoteStorage_DeletePublishedFile";
SteamAPI_ISteamRemoteStorage_EnumerateUserPublishedFiles :: (self: *ISteamRemoteStorage, unStartIndex: uint32) -> SteamAPICall_t #must #foreign steam "SteamAPI_ISteamRemoteStorage_EnumerateUserPublishedFiles";
SteamAPI_ISteamRemoteStorage_SubscribePublishedFile :: (self: *ISteamRemoteStorage, unPublishedFileId: PublishedFileId_t) -> SteamAPICall_t #must #foreign steam "SteamAPI_ISteamRemoteStorage_SubscribePublishedFile";
SteamAPI_ISteamRemoteStorage_EnumerateUserSubscribedFiles :: (self: *ISteamRemoteStorage, unStartIndex: uint32) -> SteamAPICall_t #must #foreign steam "SteamAPI_ISteamRemoteStorage_EnumerateUserSubscribedFiles";
SteamAPI_ISteamRemoteStorage_UnsubscribePublishedFile :: (self: *ISteamRemoteStorage, unPublishedFileId: PublishedFileId_t) -> SteamAPICall_t #must #foreign steam "SteamAPI_ISteamRemoteStorage_UnsubscribePublishedFile";
SteamAPI_ISteamRemoteStorage_UpdatePublishedFileSetChangeDescription :: (self: *ISteamRemoteStorage, updateHandle: PublishedFileUpdateHandle_t, pchChangeDescription: *char) -> bool #foreign steam "SteamAPI_ISteamRemoteStorage_UpdatePublishedFileSetChangeDescription";
SteamAPI_ISteamRemoteStorage_GetPublishedItemVoteDetails :: (self: *ISteamRemoteStorage, unPublishedFileId: PublishedFileId_t) -> SteamAPICall_t #must #foreign steam "SteamAPI_ISteamRemoteStorage_GetPublishedItemVoteDetails";
SteamAPI_ISteamRemoteStorage_UpdateUserPublishedItemVote :: (self: *ISteamRemoteStorage, unPublishedFileId: PublishedFileId_t, bVoteUp: bool) -> SteamAPICall_t #must #foreign steam "SteamAPI_ISteamRemoteStorage_UpdateUserPublishedItemVote";
SteamAPI_ISteamRemoteStorage_GetUserPublishedItemVoteDetails :: (self: *ISteamRemoteStorage, unPublishedFileId: PublishedFileId_t) -> SteamAPICall_t #must #foreign steam "SteamAPI_ISteamRemoteStorage_GetUserPublishedItemVoteDetails";
SteamAPI_ISteamRemoteStorage_EnumerateUserSharedWorkshopFiles :: (self: *ISteamRemoteStorage, steamId: uint64_steamid, unStartIndex: uint32, pRequiredTags: *SteamParamStringArray_t, pExcludedTags: *SteamParamStringArray_t) -> SteamAPICall_t #must #foreign steam "SteamAPI_ISteamRemoteStorage_EnumerateUserSharedWorkshopFiles";
SteamAPI_ISteamRemoteStorage_PublishVideo :: (self: *ISteamRemoteStorage, eVideoProvider: EWorkshopVideoProvider, pchVideoAccount: *char, pchVideoIdentifier: *char, pchPreviewFile: *char, nConsumerAppId: AppId_t, pchTitle: *char, pchDescription: *char, eVisibility: ERemoteStoragePublishedFileVisibility, pTags: *SteamParamStringArray_t) -> SteamAPICall_t #must #foreign steam "SteamAPI_ISteamRemoteStorage_PublishVideo";
SteamAPI_ISteamRemoteStorage_SetUserPublishedFileAction :: (self: *ISteamRemoteStorage, unPublishedFileId: PublishedFileId_t, eAction: EWorkshopFileAction) -> SteamAPICall_t #must #foreign steam "SteamAPI_ISteamRemoteStorage_SetUserPublishedFileAction";
SteamAPI_ISteamRemoteStorage_EnumeratePublishedFilesByUserAction :: (self: *ISteamRemoteStorage, eAction: EWorkshopFileAction, unStartIndex: uint32) -> SteamAPICall_t #must #foreign steam "SteamAPI_ISteamRemoteStorage_EnumeratePublishedFilesByUserAction";
SteamAPI_ISteamRemoteStorage_EnumeratePublishedWorkshopFiles :: (self: *ISteamRemoteStorage, eEnumerationType: EWorkshopEnumerationType, unStartIndex: uint32, unCount: uint32, unDays: uint32, pTags: *SteamParamStringArray_t, pUserTags: *SteamParamStringArray_t) -> SteamAPICall_t #must #foreign steam "SteamAPI_ISteamRemoteStorage_EnumeratePublishedWorkshopFiles";
SteamAPI_ISteamRemoteStorage_UGCDownloadToLocation :: (self: *ISteamRemoteStorage, hContent: UGCHandle_t, pchLocation: *char, unPriority: uint32) -> SteamAPICall_t #must #foreign steam "SteamAPI_ISteamRemoteStorage_UGCDownloadToLocation";

// ISteamUserStats
SteamAPI_SteamUserStats_v012 :: () -> *ISteamUserStats #foreign steam "SteamAPI_SteamUserStats_v012";
SteamAPI_ISteamUserStats_RequestCurrentStats :: (self: *ISteamUserStats) -> bool #foreign steam "SteamAPI_ISteamUserStats_RequestCurrentStats";
SteamAPI_ISteamUserStats_GetStatInt32 :: (self: *ISteamUserStats, pchName: *char, pData: *int32) -> bool #foreign steam "SteamAPI_ISteamUserStats_GetStatInt32";
SteamAPI_ISteamUserStats_GetStatFloat :: (self: *ISteamUserStats, pchName: *char, pData: *float) -> bool #foreign steam "SteamAPI_ISteamUserStats_GetStatFloat";
SteamAPI_ISteamUserStats_SetStatInt32 :: (self: *ISteamUserStats, pchName: *char, nData: int32) -> bool #foreign steam "SteamAPI_ISteamUserStats_SetStatInt32";
SteamAPI_ISteamUserStats_SetStatFloat :: (self: *ISteamUserStats, pchName: *char, fData: float) -> bool #foreign steam "SteamAPI_ISteamUserStats_SetStatFloat";
SteamAPI_ISteamUserStats_UpdateAvgRateStat :: (self: *ISteamUserStats, pchName: *char, flCountThisSession: float, dSessionLength: double) -> bool #foreign steam "SteamAPI_ISteamUserStats_UpdateAvgRateStat";
SteamAPI_ISteamUserStats_GetAchievement :: (self: *ISteamUserStats, pchName: *char, pbAchieved: *bool) -> bool #foreign steam "SteamAPI_ISteamUserStats_GetAchievement";
SteamAPI_ISteamUserStats_SetAchievement :: (self: *ISteamUserStats, pchName: *char) -> bool #foreign steam "SteamAPI_ISteamUserStats_SetAchievement";
SteamAPI_ISteamUserStats_ClearAchievement :: (self: *ISteamUserStats, pchName: *char) -> bool #foreign steam "SteamAPI_ISteamUserStats_ClearAchievement";
SteamAPI_ISteamUserStats_GetAchievementAndUnlockTime :: (self: *ISteamUserStats, pchName: *char, pbAchieved: *bool, punUnlockTime: *uint32) -> bool #foreign steam "SteamAPI_ISteamUserStats_GetAchievementAndUnlockTime";
SteamAPI_ISteamUserStats_StoreStats :: (self: *ISteamUserStats) -> bool #foreign steam "SteamAPI_ISteamUserStats_StoreStats";
SteamAPI_ISteamUserStats_GetAchievementIcon :: (self: *ISteamUserStats, pchName: *char) -> s32 #foreign steam "SteamAPI_ISteamUserStats_GetAchievementIcon";
SteamAPI_ISteamUserStats_GetAchievementDisplayAttribute :: (self: *ISteamUserStats, pchName: *char, pchKey: *char) -> *char #foreign steam "SteamAPI_ISteamUserStats_GetAchievementDisplayAttribute";
SteamAPI_ISteamUserStats_IndicateAchievementProgress :: (self: *ISteamUserStats, pchName: *char, nCurProgress: uint32, nMaxProgress: uint32) -> bool #foreign steam "SteamAPI_ISteamUserStats_IndicateAchievementProgress";
SteamAPI_ISteamUserStats_GetNumAchievements :: (self: *ISteamUserStats) -> uint32 #foreign steam "SteamAPI_ISteamUserStats_GetNumAchievements";
SteamAPI_ISteamUserStats_GetAchievementName :: (self: *ISteamUserStats, iAchievement: uint32) -> *char #foreign steam "SteamAPI_ISteamUserStats_GetAchievementName";
SteamAPI_ISteamUserStats_RequestUserStats :: (self: *ISteamUserStats, steamIDUser: uint64_steamid) -> SteamAPICall_t #must #foreign steam "SteamAPI_ISteamUserStats_RequestUserStats";
SteamAPI_ISteamUserStats_GetUserStatInt32 :: (self: *ISteamUserStats, steamIDUser: uint64_steamid, pchName: *char, pData: *int32) -> bool #foreign steam "SteamAPI_ISteamUserStats_GetUserStatInt32";
SteamAPI_ISteamUserStats_GetUserStatFloat :: (self: *ISteamUserStats, steamIDUser: uint64_steamid, pchName: *char, pData: *float) -> bool #foreign steam "SteamAPI_ISteamUserStats_GetUserStatFloat";
SteamAPI_ISteamUserStats_GetUserAchievement :: (self: *ISteamUserStats, steamIDUser: uint64_steamid, pchName: *char, pbAchieved: *bool) -> bool #foreign steam "SteamAPI_ISteamUserStats_GetUserAchievement";
SteamAPI_ISteamUserStats_GetUserAchievementAndUnlockTime :: (self: *ISteamUserStats, steamIDUser: uint64_steamid, pchName: *char, pbAchieved: *bool, punUnlockTime: *uint32) -> bool #foreign steam "SteamAPI_ISteamUserStats_GetUserAchievementAndUnlockTime";
SteamAPI_ISteamUserStats_ResetAllStats :: (self: *ISteamUserStats, bAchievementsToo: bool) -> bool #foreign steam "SteamAPI_ISteamUserStats_ResetAllStats";
SteamAPI_ISteamUserStats_FindOrCreateLeaderboard :: (self: *ISteamUserStats, pchLeaderboardName: *char, eLeaderboardSortMethod: ELeaderboardSortMethod, eLeaderboardDisplayType: ELeaderboardDisplayType) -> SteamAPICall_t #must #foreign steam "SteamAPI_ISteamUserStats_FindOrCreateLeaderboard";
SteamAPI_ISteamUserStats_FindLeaderboard :: (self: *ISteamUserStats, pchLeaderboardName: *char) -> SteamAPICall_t #must #foreign steam "SteamAPI_ISteamUserStats_FindLeaderboard";
SteamAPI_ISteamUserStats_GetLeaderboardName :: (self: *ISteamUserStats, hSteamLeaderboard: SteamLeaderboard_t) -> *char #foreign steam "SteamAPI_ISteamUserStats_GetLeaderboardName";
SteamAPI_ISteamUserStats_GetLeaderboardEntryCount :: (self: *ISteamUserStats, hSteamLeaderboard: SteamLeaderboard_t) -> s32 #foreign steam "SteamAPI_ISteamUserStats_GetLeaderboardEntryCount";
SteamAPI_ISteamUserStats_GetLeaderboardSortMethod :: (self: *ISteamUserStats, hSteamLeaderboard: SteamLeaderboard_t) -> ELeaderboardSortMethod #foreign steam "SteamAPI_ISteamUserStats_GetLeaderboardSortMethod";
SteamAPI_ISteamUserStats_GetLeaderboardDisplayType :: (self: *ISteamUserStats, hSteamLeaderboard: SteamLeaderboard_t) -> ELeaderboardDisplayType #foreign steam "SteamAPI_ISteamUserStats_GetLeaderboardDisplayType";
SteamAPI_ISteamUserStats_DownloadLeaderboardEntries :: (self: *ISteamUserStats, hSteamLeaderboard: SteamLeaderboard_t, eLeaderboardDataRequest: ELeaderboardDataRequest, nRangeStart: s32, nRangeEnd: s32) -> SteamAPICall_t #must #foreign steam "SteamAPI_ISteamUserStats_DownloadLeaderboardEntries";
SteamAPI_ISteamUserStats_DownloadLeaderboardEntriesForUsers :: (self: *ISteamUserStats, hSteamLeaderboard: SteamLeaderboard_t, prgUsers: *CSteamID, cUsers: s32) -> SteamAPICall_t #must #foreign steam "SteamAPI_ISteamUserStats_DownloadLeaderboardEntriesForUsers";
SteamAPI_ISteamUserStats_GetDownloadedLeaderboardEntry :: (self: *ISteamUserStats, hSteamLeaderboardEntries: SteamLeaderboardEntries_t, index: s32, pLeaderboardEntry: *LeaderboardEntry_t, pDetails: *int32, cDetailsMax: s32) -> bool #foreign steam "SteamAPI_ISteamUserStats_GetDownloadedLeaderboardEntry";
SteamAPI_ISteamUserStats_UploadLeaderboardScore :: (self: *ISteamUserStats, hSteamLeaderboard: SteamLeaderboard_t, eLeaderboardUploadScoreMethod: ELeaderboardUploadScoreMethod, nScore: int32, pScoreDetails: *int32, cScoreDetailsCount: s32) -> SteamAPICall_t #must #foreign steam "SteamAPI_ISteamUserStats_UploadLeaderboardScore";
SteamAPI_ISteamUserStats_AttachLeaderboardUGC :: (self: *ISteamUserStats, hSteamLeaderboard: SteamLeaderboard_t, hUGC: UGCHandle_t) -> SteamAPICall_t #must #foreign steam "SteamAPI_ISteamUserStats_AttachLeaderboardUGC";
SteamAPI_ISteamUserStats_GetNumberOfCurrentPlayers :: (self: *ISteamUserStats) -> SteamAPICall_t #must #foreign steam "SteamAPI_ISteamUserStats_GetNumberOfCurrentPlayers";
SteamAPI_ISteamUserStats_RequestGlobalAchievementPercentages :: (self: *ISteamUserStats) -> SteamAPICall_t #must #foreign steam "SteamAPI_ISteamUserStats_RequestGlobalAchievementPercentages";
SteamAPI_ISteamUserStats_GetMostAchievedAchievementInfo :: (self: *ISteamUserStats, pchName: *char, unNameBufLen: uint32, pflPercent: *float, pbAchieved: *bool) -> s32 #foreign steam "SteamAPI_ISteamUserStats_GetMostAchievedAchievementInfo";
SteamAPI_ISteamUserStats_GetNextMostAchievedAchievementInfo :: (self: *ISteamUserStats, iIteratorPrevious: s32, pchName: *char, unNameBufLen: uint32, pflPercent: *float, pbAchieved: *bool) -> s32 #foreign steam "SteamAPI_ISteamUserStats_GetNextMostAchievedAchievementInfo";
SteamAPI_ISteamUserStats_GetAchievementAchievedPercent :: (self: *ISteamUserStats, pchName: *char, pflPercent: *float) -> bool #foreign steam "SteamAPI_ISteamUserStats_GetAchievementAchievedPercent";
SteamAPI_ISteamUserStats_RequestGlobalStats :: (self: *ISteamUserStats, nHistoryDays: s32) -> SteamAPICall_t #must #foreign steam "SteamAPI_ISteamUserStats_RequestGlobalStats";
SteamAPI_ISteamUserStats_GetGlobalStatInt64 :: (self: *ISteamUserStats, pchStatName: *char, pData: *int64) -> bool #foreign steam "SteamAPI_ISteamUserStats_GetGlobalStatInt64";
SteamAPI_ISteamUserStats_GetGlobalStatDouble :: (self: *ISteamUserStats, pchStatName: *char, pData: *double) -> bool #foreign steam "SteamAPI_ISteamUserStats_GetGlobalStatDouble";
SteamAPI_ISteamUserStats_GetGlobalStatHistoryInt64 :: (self: *ISteamUserStats, pchStatName: *char, pData: *int64, cubData: uint32) -> int32 #foreign steam "SteamAPI_ISteamUserStats_GetGlobalStatHistoryInt64";
SteamAPI_ISteamUserStats_GetGlobalStatHistoryDouble :: (self: *ISteamUserStats, pchStatName: *char, pData: *double, cubData: uint32) -> int32 #foreign steam "SteamAPI_ISteamUserStats_GetGlobalStatHistoryDouble";
SteamAPI_ISteamUserStats_GetAchievementProgressLimitsInt32 :: (self: *ISteamUserStats, pchName: *char, pnMinProgress: *int32, pnMaxProgress: *int32) -> bool #foreign steam "SteamAPI_ISteamUserStats_GetAchievementProgressLimitsInt32";
SteamAPI_ISteamUserStats_GetAchievementProgressLimitsFloat :: (self: *ISteamUserStats, pchName: *char, pfMinProgress: *float, pfMaxProgress: *float) -> bool #foreign steam "SteamAPI_ISteamUserStats_GetAchievementProgressLimitsFloat";

// ISteamApps
SteamAPI_SteamApps_v008 :: () -> *ISteamApps #foreign steam "SteamAPI_SteamApps_v008";
SteamAPI_SteamGameServerApps_v008 :: () -> *ISteamApps #foreign steam "SteamAPI_SteamGameServerApps_v008";
SteamAPI_ISteamApps_BIsSubscribed :: (self: *ISteamApps) -> bool #foreign steam "SteamAPI_ISteamApps_BIsSubscribed";
SteamAPI_ISteamApps_BIsLowViolence :: (self: *ISteamApps) -> bool #foreign steam "SteamAPI_ISteamApps_BIsLowViolence";
SteamAPI_ISteamApps_BIsCybercafe :: (self: *ISteamApps) -> bool #foreign steam "SteamAPI_ISteamApps_BIsCybercafe";
SteamAPI_ISteamApps_BIsVACBanned :: (self: *ISteamApps) -> bool #foreign steam "SteamAPI_ISteamApps_BIsVACBanned";
SteamAPI_ISteamApps_GetCurrentGameLanguage :: (self: *ISteamApps) -> *char #foreign steam "SteamAPI_ISteamApps_GetCurrentGameLanguage";
SteamAPI_ISteamApps_GetAvailableGameLanguages :: (self: *ISteamApps) -> *char #foreign steam "SteamAPI_ISteamApps_GetAvailableGameLanguages";
SteamAPI_ISteamApps_BIsSubscribedApp :: (self: *ISteamApps, appID: AppId_t) -> bool #foreign steam "SteamAPI_ISteamApps_BIsSubscribedApp";
SteamAPI_ISteamApps_BIsDlcInstalled :: (self: *ISteamApps, appID: AppId_t) -> bool #foreign steam "SteamAPI_ISteamApps_BIsDlcInstalled";
SteamAPI_ISteamApps_GetEarliestPurchaseUnixTime :: (self: *ISteamApps, nAppID: AppId_t) -> uint32 #foreign steam "SteamAPI_ISteamApps_GetEarliestPurchaseUnixTime";
SteamAPI_ISteamApps_BIsSubscribedFromFreeWeekend :: (self: *ISteamApps) -> bool #foreign steam "SteamAPI_ISteamApps_BIsSubscribedFromFreeWeekend";
SteamAPI_ISteamApps_GetDLCCount :: (self: *ISteamApps) -> s32 #foreign steam "SteamAPI_ISteamApps_GetDLCCount";
SteamAPI_ISteamApps_BGetDLCDataByIndex :: (self: *ISteamApps, iDLC: s32, pAppID: *AppId_t, pbAvailable: *bool, pchName: *char, cchNameBufferSize: s32) -> bool #foreign steam "SteamAPI_ISteamApps_BGetDLCDataByIndex";
SteamAPI_ISteamApps_InstallDLC :: (self: *ISteamApps, nAppID: AppId_t) #foreign steam "SteamAPI_ISteamApps_InstallDLC";
SteamAPI_ISteamApps_UninstallDLC :: (self: *ISteamApps, nAppID: AppId_t) #foreign steam "SteamAPI_ISteamApps_UninstallDLC";
SteamAPI_ISteamApps_RequestAppProofOfPurchaseKey :: (self: *ISteamApps, nAppID: AppId_t) #foreign steam "SteamAPI_ISteamApps_RequestAppProofOfPurchaseKey";
SteamAPI_ISteamApps_GetCurrentBetaName :: (self: *ISteamApps, pchName: *char, cchNameBufferSize: s32) -> bool #foreign steam "SteamAPI_ISteamApps_GetCurrentBetaName";
SteamAPI_ISteamApps_MarkContentCorrupt :: (self: *ISteamApps, bMissingFilesOnly: bool) -> bool #foreign steam "SteamAPI_ISteamApps_MarkContentCorrupt";
SteamAPI_ISteamApps_GetInstalledDepots :: (self: *ISteamApps, appID: AppId_t, pvecDepots: *DepotId_t, cMaxDepots: uint32) -> uint32 #foreign steam "SteamAPI_ISteamApps_GetInstalledDepots";
SteamAPI_ISteamApps_GetAppInstallDir :: (self: *ISteamApps, appID: AppId_t, pchFolder: *char, cchFolderBufferSize: uint32) -> uint32 #foreign steam "SteamAPI_ISteamApps_GetAppInstallDir";
SteamAPI_ISteamApps_BIsAppInstalled :: (self: *ISteamApps, appID: AppId_t) -> bool #foreign steam "SteamAPI_ISteamApps_BIsAppInstalled";
SteamAPI_ISteamApps_GetAppOwner :: (self: *ISteamApps) -> uint64_steamid #foreign steam "SteamAPI_ISteamApps_GetAppOwner";
SteamAPI_ISteamApps_GetLaunchQueryParam :: (self: *ISteamApps, pchKey: *char) -> *char #foreign steam "SteamAPI_ISteamApps_GetLaunchQueryParam";
SteamAPI_ISteamApps_GetDlcDownloadProgress :: (self: *ISteamApps, nAppID: AppId_t, punBytesDownloaded: *uint64, punBytesTotal: *uint64) -> bool #foreign steam "SteamAPI_ISteamApps_GetDlcDownloadProgress";
SteamAPI_ISteamApps_GetAppBuildId :: (self: *ISteamApps) -> s32 #foreign steam "SteamAPI_ISteamApps_GetAppBuildId";
SteamAPI_ISteamApps_RequestAllProofOfPurchaseKeys :: (self: *ISteamApps) #foreign steam "SteamAPI_ISteamApps_RequestAllProofOfPurchaseKeys";
SteamAPI_ISteamApps_GetFileDetails :: (self: *ISteamApps, pszFileName: *char) -> SteamAPICall_t #must #foreign steam "SteamAPI_ISteamApps_GetFileDetails";
SteamAPI_ISteamApps_GetLaunchCommandLine :: (self: *ISteamApps, pszCommandLine: *char, cubCommandLine: s32) -> s32 #foreign steam "SteamAPI_ISteamApps_GetLaunchCommandLine";
SteamAPI_ISteamApps_BIsSubscribedFromFamilySharing :: (self: *ISteamApps) -> bool #foreign steam "SteamAPI_ISteamApps_BIsSubscribedFromFamilySharing";
SteamAPI_ISteamApps_BIsTimedTrial :: (self: *ISteamApps, punSecondsAllowed: *uint32, punSecondsPlayed: *uint32) -> bool #foreign steam "SteamAPI_ISteamApps_BIsTimedTrial";

// ISteamNetworking
SteamAPI_SteamNetworking_v006 :: () -> *ISteamNetworking #foreign steam "SteamAPI_SteamNetworking_v006";
SteamAPI_SteamGameServerNetworking_v006 :: () -> *ISteamNetworking #foreign steam "SteamAPI_SteamGameServerNetworking_v006";
SteamAPI_ISteamNetworking_SendP2PPacket :: (self: *ISteamNetworking, steamIDRemote: uint64_steamid, pubData: *void, cubData: uint32, eP2PSendType: EP2PSend, nChannel: s32) -> bool #foreign steam "SteamAPI_ISteamNetworking_SendP2PPacket";
SteamAPI_ISteamNetworking_IsP2PPacketAvailable :: (self: *ISteamNetworking, pcubMsgSize: *uint32, nChannel: s32) -> bool #foreign steam "SteamAPI_ISteamNetworking_IsP2PPacketAvailable";
SteamAPI_ISteamNetworking_ReadP2PPacket :: (self: *ISteamNetworking, pubDest: *void, cubDest: uint32, pcubMsgSize: *uint32, psteamIDRemote: *CSteamID, nChannel: s32) -> bool #foreign steam "SteamAPI_ISteamNetworking_ReadP2PPacket";
SteamAPI_ISteamNetworking_AcceptP2PSessionWithUser :: (self: *ISteamNetworking, steamIDRemote: uint64_steamid) -> bool #foreign steam "SteamAPI_ISteamNetworking_AcceptP2PSessionWithUser";
SteamAPI_ISteamNetworking_CloseP2PSessionWithUser :: (self: *ISteamNetworking, steamIDRemote: uint64_steamid) -> bool #foreign steam "SteamAPI_ISteamNetworking_CloseP2PSessionWithUser";
SteamAPI_ISteamNetworking_CloseP2PChannelWithUser :: (self: *ISteamNetworking, steamIDRemote: uint64_steamid, nChannel: s32) -> bool #foreign steam "SteamAPI_ISteamNetworking_CloseP2PChannelWithUser";
SteamAPI_ISteamNetworking_GetP2PSessionState :: (self: *ISteamNetworking, steamIDRemote: uint64_steamid, pConnectionState: *P2PSessionState_t) -> bool #foreign steam "SteamAPI_ISteamNetworking_GetP2PSessionState";
SteamAPI_ISteamNetworking_AllowP2PPacketRelay :: (self: *ISteamNetworking, bAllow: bool) -> bool #foreign steam "SteamAPI_ISteamNetworking_AllowP2PPacketRelay";
SteamAPI_ISteamNetworking_CreateListenSocket :: (self: *ISteamNetworking, nVirtualP2PPort: s32, nIP: SteamIPAddress_t, nPort: uint16, bAllowUseOfPacketRelay: bool) -> SNetListenSocket_t #foreign steam "SteamAPI_ISteamNetworking_CreateListenSocket";
SteamAPI_ISteamNetworking_CreateP2PConnectionSocket :: (self: *ISteamNetworking, steamIDTarget: uint64_steamid, nVirtualPort: s32, nTimeoutSec: s32, bAllowUseOfPacketRelay: bool) -> SNetSocket_t #foreign steam "SteamAPI_ISteamNetworking_CreateP2PConnectionSocket";
SteamAPI_ISteamNetworking_CreateConnectionSocket :: (self: *ISteamNetworking, nIP: SteamIPAddress_t, nPort: uint16, nTimeoutSec: s32) -> SNetSocket_t #foreign steam "SteamAPI_ISteamNetworking_CreateConnectionSocket";
SteamAPI_ISteamNetworking_DestroySocket :: (self: *ISteamNetworking, hSocket: SNetSocket_t, bNotifyRemoteEnd: bool) -> bool #foreign steam "SteamAPI_ISteamNetworking_DestroySocket";
SteamAPI_ISteamNetworking_DestroyListenSocket :: (self: *ISteamNetworking, hSocket: SNetListenSocket_t, bNotifyRemoteEnd: bool) -> bool #foreign steam "SteamAPI_ISteamNetworking_DestroyListenSocket";
SteamAPI_ISteamNetworking_SendDataOnSocket :: (self: *ISteamNetworking, hSocket: SNetSocket_t, pubData: *void, cubData: uint32, bReliable: bool) -> bool #foreign steam "SteamAPI_ISteamNetworking_SendDataOnSocket";
SteamAPI_ISteamNetworking_IsDataAvailableOnSocket :: (self: *ISteamNetworking, hSocket: SNetSocket_t, pcubMsgSize: *uint32) -> bool #foreign steam "SteamAPI_ISteamNetworking_IsDataAvailableOnSocket";
SteamAPI_ISteamNetworking_RetrieveDataFromSocket :: (self: *ISteamNetworking, hSocket: SNetSocket_t, pubDest: *void, cubDest: uint32, pcubMsgSize: *uint32) -> bool #foreign steam "SteamAPI_ISteamNetworking_RetrieveDataFromSocket";
SteamAPI_ISteamNetworking_IsDataAvailable :: (self: *ISteamNetworking, hListenSocket: SNetListenSocket_t, pcubMsgSize: *uint32, phSocket: *SNetSocket_t) -> bool #foreign steam "SteamAPI_ISteamNetworking_IsDataAvailable";
SteamAPI_ISteamNetworking_RetrieveData :: (self: *ISteamNetworking, hListenSocket: SNetListenSocket_t, pubDest: *void, cubDest: uint32, pcubMsgSize: *uint32, phSocket: *SNetSocket_t) -> bool #foreign steam "SteamAPI_ISteamNetworking_RetrieveData";
SteamAPI_ISteamNetworking_GetSocketInfo :: (self: *ISteamNetworking, hSocket: SNetSocket_t, pSteamIDRemote: *CSteamID, peSocketStatus: *s32, punIPRemote: *SteamIPAddress_t, punPortRemote: *uint16) -> bool #foreign steam "SteamAPI_ISteamNetworking_GetSocketInfo";
SteamAPI_ISteamNetworking_GetListenSocketInfo :: (self: *ISteamNetworking, hListenSocket: SNetListenSocket_t, pnIP: *SteamIPAddress_t, pnPort: *uint16) -> bool #foreign steam "SteamAPI_ISteamNetworking_GetListenSocketInfo";
SteamAPI_ISteamNetworking_GetSocketConnectionType :: (self: *ISteamNetworking, hSocket: SNetSocket_t) -> ESNetSocketConnectionType #foreign steam "SteamAPI_ISteamNetworking_GetSocketConnectionType";
SteamAPI_ISteamNetworking_GetMaxPacketSize :: (self: *ISteamNetworking, hSocket: SNetSocket_t) -> s32 #foreign steam "SteamAPI_ISteamNetworking_GetMaxPacketSize";

// ISteamScreenshots
SteamAPI_SteamScreenshots_v003 :: () -> *ISteamScreenshots #foreign steam "SteamAPI_SteamScreenshots_v003";
SteamAPI_ISteamScreenshots_WriteScreenshot :: (self: *ISteamScreenshots, pubRGB: *void, cubRGB: uint32, nWidth: s32, nHeight: s32) -> ScreenshotHandle #foreign steam "SteamAPI_ISteamScreenshots_WriteScreenshot";
SteamAPI_ISteamScreenshots_AddScreenshotToLibrary :: (self: *ISteamScreenshots, pchFilename: *char, pchThumbnailFilename: *char, nWidth: s32, nHeight: s32) -> ScreenshotHandle #foreign steam "SteamAPI_ISteamScreenshots_AddScreenshotToLibrary";
SteamAPI_ISteamScreenshots_TriggerScreenshot :: (self: *ISteamScreenshots) #foreign steam "SteamAPI_ISteamScreenshots_TriggerScreenshot";
SteamAPI_ISteamScreenshots_HookScreenshots :: (self: *ISteamScreenshots, bHook: bool) #foreign steam "SteamAPI_ISteamScreenshots_HookScreenshots";
SteamAPI_ISteamScreenshots_SetLocation :: (self: *ISteamScreenshots, hScreenshot: ScreenshotHandle, pchLocation: *char) -> bool #foreign steam "SteamAPI_ISteamScreenshots_SetLocation";
SteamAPI_ISteamScreenshots_TagUser :: (self: *ISteamScreenshots, hScreenshot: ScreenshotHandle, steamID: uint64_steamid) -> bool #foreign steam "SteamAPI_ISteamScreenshots_TagUser";
SteamAPI_ISteamScreenshots_TagPublishedFile :: (self: *ISteamScreenshots, hScreenshot: ScreenshotHandle, unPublishedFileID: PublishedFileId_t) -> bool #foreign steam "SteamAPI_ISteamScreenshots_TagPublishedFile";
SteamAPI_ISteamScreenshots_IsScreenshotsHooked :: (self: *ISteamScreenshots) -> bool #foreign steam "SteamAPI_ISteamScreenshots_IsScreenshotsHooked";
SteamAPI_ISteamScreenshots_AddVRScreenshotToLibrary :: (self: *ISteamScreenshots, eType: EVRScreenshotType, pchFilename: *char, pchVRFilename: *char) -> ScreenshotHandle #foreign steam "SteamAPI_ISteamScreenshots_AddVRScreenshotToLibrary";

// ISteamMusic
SteamAPI_SteamMusic_v001 :: () -> *ISteamMusic #foreign steam "SteamAPI_SteamMusic_v001";
SteamAPI_ISteamMusic_BIsEnabled :: (self: *ISteamMusic) -> bool #foreign steam "SteamAPI_ISteamMusic_BIsEnabled";
SteamAPI_ISteamMusic_BIsPlaying :: (self: *ISteamMusic) -> bool #foreign steam "SteamAPI_ISteamMusic_BIsPlaying";
SteamAPI_ISteamMusic_GetPlaybackStatus :: (self: *ISteamMusic) -> AudioPlayback_Status #foreign steam "SteamAPI_ISteamMusic_GetPlaybackStatus";
SteamAPI_ISteamMusic_Play :: (self: *ISteamMusic) #foreign steam "SteamAPI_ISteamMusic_Play";
SteamAPI_ISteamMusic_Pause :: (self: *ISteamMusic) #foreign steam "SteamAPI_ISteamMusic_Pause";
SteamAPI_ISteamMusic_PlayPrevious :: (self: *ISteamMusic) #foreign steam "SteamAPI_ISteamMusic_PlayPrevious";
SteamAPI_ISteamMusic_PlayNext :: (self: *ISteamMusic) #foreign steam "SteamAPI_ISteamMusic_PlayNext";
SteamAPI_ISteamMusic_SetVolume :: (self: *ISteamMusic, flVolume: float) #foreign steam "SteamAPI_ISteamMusic_SetVolume";
SteamAPI_ISteamMusic_GetVolume :: (self: *ISteamMusic) -> float #foreign steam "SteamAPI_ISteamMusic_GetVolume";

// ISteamMusicRemote
SteamAPI_SteamMusicRemote_v001 :: () -> *ISteamMusicRemote #foreign steam "SteamAPI_SteamMusicRemote_v001";
SteamAPI_ISteamMusicRemote_RegisterSteamMusicRemote :: (self: *ISteamMusicRemote, pchName: *char) -> bool #foreign steam "SteamAPI_ISteamMusicRemote_RegisterSteamMusicRemote";
SteamAPI_ISteamMusicRemote_DeregisterSteamMusicRemote :: (self: *ISteamMusicRemote) -> bool #foreign steam "SteamAPI_ISteamMusicRemote_DeregisterSteamMusicRemote";
SteamAPI_ISteamMusicRemote_BIsCurrentMusicRemote :: (self: *ISteamMusicRemote) -> bool #foreign steam "SteamAPI_ISteamMusicRemote_BIsCurrentMusicRemote";
SteamAPI_ISteamMusicRemote_BActivationSuccess :: (self: *ISteamMusicRemote, bValue: bool) -> bool #foreign steam "SteamAPI_ISteamMusicRemote_BActivationSuccess";
SteamAPI_ISteamMusicRemote_SetDisplayName :: (self: *ISteamMusicRemote, pchDisplayName: *char) -> bool #foreign steam "SteamAPI_ISteamMusicRemote_SetDisplayName";
SteamAPI_ISteamMusicRemote_SetPNGIcon_64x64 :: (self: *ISteamMusicRemote, pvBuffer: *void, cbBufferLength: uint32) -> bool #foreign steam "SteamAPI_ISteamMusicRemote_SetPNGIcon_64x64";
SteamAPI_ISteamMusicRemote_EnablePlayPrevious :: (self: *ISteamMusicRemote, bValue: bool) -> bool #foreign steam "SteamAPI_ISteamMusicRemote_EnablePlayPrevious";
SteamAPI_ISteamMusicRemote_EnablePlayNext :: (self: *ISteamMusicRemote, bValue: bool) -> bool #foreign steam "SteamAPI_ISteamMusicRemote_EnablePlayNext";
SteamAPI_ISteamMusicRemote_EnableShuffled :: (self: *ISteamMusicRemote, bValue: bool) -> bool #foreign steam "SteamAPI_ISteamMusicRemote_EnableShuffled";
SteamAPI_ISteamMusicRemote_EnableLooped :: (self: *ISteamMusicRemote, bValue: bool) -> bool #foreign steam "SteamAPI_ISteamMusicRemote_EnableLooped";
SteamAPI_ISteamMusicRemote_EnableQueue :: (self: *ISteamMusicRemote, bValue: bool) -> bool #foreign steam "SteamAPI_ISteamMusicRemote_EnableQueue";
SteamAPI_ISteamMusicRemote_EnablePlaylists :: (self: *ISteamMusicRemote, bValue: bool) -> bool #foreign steam "SteamAPI_ISteamMusicRemote_EnablePlaylists";
SteamAPI_ISteamMusicRemote_UpdatePlaybackStatus :: (self: *ISteamMusicRemote, nStatus: AudioPlayback_Status) -> bool #foreign steam "SteamAPI_ISteamMusicRemote_UpdatePlaybackStatus";
SteamAPI_ISteamMusicRemote_UpdateShuffled :: (self: *ISteamMusicRemote, bValue: bool) -> bool #foreign steam "SteamAPI_ISteamMusicRemote_UpdateShuffled";
SteamAPI_ISteamMusicRemote_UpdateLooped :: (self: *ISteamMusicRemote, bValue: bool) -> bool #foreign steam "SteamAPI_ISteamMusicRemote_UpdateLooped";
SteamAPI_ISteamMusicRemote_UpdateVolume :: (self: *ISteamMusicRemote, flValue: float) -> bool #foreign steam "SteamAPI_ISteamMusicRemote_UpdateVolume";
SteamAPI_ISteamMusicRemote_CurrentEntryWillChange :: (self: *ISteamMusicRemote) -> bool #foreign steam "SteamAPI_ISteamMusicRemote_CurrentEntryWillChange";
SteamAPI_ISteamMusicRemote_CurrentEntryIsAvailable :: (self: *ISteamMusicRemote, bAvailable: bool) -> bool #foreign steam "SteamAPI_ISteamMusicRemote_CurrentEntryIsAvailable";
SteamAPI_ISteamMusicRemote_UpdateCurrentEntryText :: (self: *ISteamMusicRemote, pchText: *char) -> bool #foreign steam "SteamAPI_ISteamMusicRemote_UpdateCurrentEntryText";
SteamAPI_ISteamMusicRemote_UpdateCurrentEntryElapsedSeconds :: (self: *ISteamMusicRemote, nValue: s32) -> bool #foreign steam "SteamAPI_ISteamMusicRemote_UpdateCurrentEntryElapsedSeconds";
SteamAPI_ISteamMusicRemote_UpdateCurrentEntryCoverArt :: (self: *ISteamMusicRemote, pvBuffer: *void, cbBufferLength: uint32) -> bool #foreign steam "SteamAPI_ISteamMusicRemote_UpdateCurrentEntryCoverArt";
SteamAPI_ISteamMusicRemote_CurrentEntryDidChange :: (self: *ISteamMusicRemote) -> bool #foreign steam "SteamAPI_ISteamMusicRemote_CurrentEntryDidChange";
SteamAPI_ISteamMusicRemote_QueueWillChange :: (self: *ISteamMusicRemote) -> bool #foreign steam "SteamAPI_ISteamMusicRemote_QueueWillChange";
SteamAPI_ISteamMusicRemote_ResetQueueEntries :: (self: *ISteamMusicRemote) -> bool #foreign steam "SteamAPI_ISteamMusicRemote_ResetQueueEntries";
SteamAPI_ISteamMusicRemote_SetQueueEntry :: (self: *ISteamMusicRemote, nID: s32, nPosition: s32, pchEntryText: *char) -> bool #foreign steam "SteamAPI_ISteamMusicRemote_SetQueueEntry";
SteamAPI_ISteamMusicRemote_SetCurrentQueueEntry :: (self: *ISteamMusicRemote, nID: s32) -> bool #foreign steam "SteamAPI_ISteamMusicRemote_SetCurrentQueueEntry";
SteamAPI_ISteamMusicRemote_QueueDidChange :: (self: *ISteamMusicRemote) -> bool #foreign steam "SteamAPI_ISteamMusicRemote_QueueDidChange";
SteamAPI_ISteamMusicRemote_PlaylistWillChange :: (self: *ISteamMusicRemote) -> bool #foreign steam "SteamAPI_ISteamMusicRemote_PlaylistWillChange";
SteamAPI_ISteamMusicRemote_ResetPlaylistEntries :: (self: *ISteamMusicRemote) -> bool #foreign steam "SteamAPI_ISteamMusicRemote_ResetPlaylistEntries";
SteamAPI_ISteamMusicRemote_SetPlaylistEntry :: (self: *ISteamMusicRemote, nID: s32, nPosition: s32, pchEntryText: *char) -> bool #foreign steam "SteamAPI_ISteamMusicRemote_SetPlaylistEntry";
SteamAPI_ISteamMusicRemote_SetCurrentPlaylistEntry :: (self: *ISteamMusicRemote, nID: s32) -> bool #foreign steam "SteamAPI_ISteamMusicRemote_SetCurrentPlaylistEntry";
SteamAPI_ISteamMusicRemote_PlaylistDidChange :: (self: *ISteamMusicRemote) -> bool #foreign steam "SteamAPI_ISteamMusicRemote_PlaylistDidChange";

// ISteamHTTP
SteamAPI_SteamHTTP_v003 :: () -> *ISteamHTTP #foreign steam "SteamAPI_SteamHTTP_v003";
SteamAPI_SteamGameServerHTTP_v003 :: () -> *ISteamHTTP #foreign steam "SteamAPI_SteamGameServerHTTP_v003";
SteamAPI_ISteamHTTP_CreateHTTPRequest :: (self: *ISteamHTTP, eHTTPRequestMethod: EHTTPMethod, pchAbsoluteURL: *char) -> HTTPRequestHandle #foreign steam "SteamAPI_ISteamHTTP_CreateHTTPRequest";
SteamAPI_ISteamHTTP_SetHTTPRequestContextValue :: (self: *ISteamHTTP, hRequest: HTTPRequestHandle, ulContextValue: uint64) -> bool #foreign steam "SteamAPI_ISteamHTTP_SetHTTPRequestContextValue";
SteamAPI_ISteamHTTP_SetHTTPRequestNetworkActivityTimeout :: (self: *ISteamHTTP, hRequest: HTTPRequestHandle, unTimeoutSeconds: uint32) -> bool #foreign steam "SteamAPI_ISteamHTTP_SetHTTPRequestNetworkActivityTimeout";
SteamAPI_ISteamHTTP_SetHTTPRequestHeaderValue :: (self: *ISteamHTTP, hRequest: HTTPRequestHandle, pchHeaderName: *char, pchHeaderValue: *char) -> bool #foreign steam "SteamAPI_ISteamHTTP_SetHTTPRequestHeaderValue";
SteamAPI_ISteamHTTP_SetHTTPRequestGetOrPostParameter :: (self: *ISteamHTTP, hRequest: HTTPRequestHandle, pchParamName: *char, pchParamValue: *char) -> bool #foreign steam "SteamAPI_ISteamHTTP_SetHTTPRequestGetOrPostParameter";
SteamAPI_ISteamHTTP_SendHTTPRequest :: (self: *ISteamHTTP, hRequest: HTTPRequestHandle, pCallHandle: *SteamAPICall_t) -> bool #foreign steam "SteamAPI_ISteamHTTP_SendHTTPRequest";
SteamAPI_ISteamHTTP_SendHTTPRequestAndStreamResponse :: (self: *ISteamHTTP, hRequest: HTTPRequestHandle, pCallHandle: *SteamAPICall_t) -> bool #foreign steam "SteamAPI_ISteamHTTP_SendHTTPRequestAndStreamResponse";
SteamAPI_ISteamHTTP_DeferHTTPRequest :: (self: *ISteamHTTP, hRequest: HTTPRequestHandle) -> bool #foreign steam "SteamAPI_ISteamHTTP_DeferHTTPRequest";
SteamAPI_ISteamHTTP_PrioritizeHTTPRequest :: (self: *ISteamHTTP, hRequest: HTTPRequestHandle) -> bool #foreign steam "SteamAPI_ISteamHTTP_PrioritizeHTTPRequest";
SteamAPI_ISteamHTTP_GetHTTPResponseHeaderSize :: (self: *ISteamHTTP, hRequest: HTTPRequestHandle, pchHeaderName: *char, unResponseHeaderSize: *uint32) -> bool #foreign steam "SteamAPI_ISteamHTTP_GetHTTPResponseHeaderSize";
SteamAPI_ISteamHTTP_GetHTTPResponseHeaderValue :: (self: *ISteamHTTP, hRequest: HTTPRequestHandle, pchHeaderName: *char, pHeaderValueBuffer: *uint8, unBufferSize: uint32) -> bool #foreign steam "SteamAPI_ISteamHTTP_GetHTTPResponseHeaderValue";
SteamAPI_ISteamHTTP_GetHTTPResponseBodySize :: (self: *ISteamHTTP, hRequest: HTTPRequestHandle, unBodySize: *uint32) -> bool #foreign steam "SteamAPI_ISteamHTTP_GetHTTPResponseBodySize";
SteamAPI_ISteamHTTP_GetHTTPResponseBodyData :: (self: *ISteamHTTP, hRequest: HTTPRequestHandle, pBodyDataBuffer: *uint8, unBufferSize: uint32) -> bool #foreign steam "SteamAPI_ISteamHTTP_GetHTTPResponseBodyData";
SteamAPI_ISteamHTTP_GetHTTPStreamingResponseBodyData :: (self: *ISteamHTTP, hRequest: HTTPRequestHandle, cOffset: uint32, pBodyDataBuffer: *uint8, unBufferSize: uint32) -> bool #foreign steam "SteamAPI_ISteamHTTP_GetHTTPStreamingResponseBodyData";
SteamAPI_ISteamHTTP_ReleaseHTTPRequest :: (self: *ISteamHTTP, hRequest: HTTPRequestHandle) -> bool #foreign steam "SteamAPI_ISteamHTTP_ReleaseHTTPRequest";
SteamAPI_ISteamHTTP_GetHTTPDownloadProgressPct :: (self: *ISteamHTTP, hRequest: HTTPRequestHandle, pflPercentOut: *float) -> bool #foreign steam "SteamAPI_ISteamHTTP_GetHTTPDownloadProgressPct";
SteamAPI_ISteamHTTP_SetHTTPRequestRawPostBody :: (self: *ISteamHTTP, hRequest: HTTPRequestHandle, pchContentType: *char, pubBody: *uint8, unBodyLen: uint32) -> bool #foreign steam "SteamAPI_ISteamHTTP_SetHTTPRequestRawPostBody";
SteamAPI_ISteamHTTP_CreateCookieContainer :: (self: *ISteamHTTP, bAllowResponsesToModify: bool) -> HTTPCookieContainerHandle #foreign steam "SteamAPI_ISteamHTTP_CreateCookieContainer";
SteamAPI_ISteamHTTP_ReleaseCookieContainer :: (self: *ISteamHTTP, hCookieContainer: HTTPCookieContainerHandle) -> bool #foreign steam "SteamAPI_ISteamHTTP_ReleaseCookieContainer";
SteamAPI_ISteamHTTP_SetCookie :: (self: *ISteamHTTP, hCookieContainer: HTTPCookieContainerHandle, pchHost: *char, pchUrl: *char, pchCookie: *char) -> bool #foreign steam "SteamAPI_ISteamHTTP_SetCookie";
SteamAPI_ISteamHTTP_SetHTTPRequestCookieContainer :: (self: *ISteamHTTP, hRequest: HTTPRequestHandle, hCookieContainer: HTTPCookieContainerHandle) -> bool #foreign steam "SteamAPI_ISteamHTTP_SetHTTPRequestCookieContainer";
SteamAPI_ISteamHTTP_SetHTTPRequestUserAgentInfo :: (self: *ISteamHTTP, hRequest: HTTPRequestHandle, pchUserAgentInfo: *char) -> bool #foreign steam "SteamAPI_ISteamHTTP_SetHTTPRequestUserAgentInfo";
SteamAPI_ISteamHTTP_SetHTTPRequestRequiresVerifiedCertificate :: (self: *ISteamHTTP, hRequest: HTTPRequestHandle, bRequireVerifiedCertificate: bool) -> bool #foreign steam "SteamAPI_ISteamHTTP_SetHTTPRequestRequiresVerifiedCertificate";
SteamAPI_ISteamHTTP_SetHTTPRequestAbsoluteTimeoutMS :: (self: *ISteamHTTP, hRequest: HTTPRequestHandle, unMilliseconds: uint32) -> bool #foreign steam "SteamAPI_ISteamHTTP_SetHTTPRequestAbsoluteTimeoutMS";
SteamAPI_ISteamHTTP_GetHTTPRequestWasTimedOut :: (self: *ISteamHTTP, hRequest: HTTPRequestHandle, pbWasTimedOut: *bool) -> bool #foreign steam "SteamAPI_ISteamHTTP_GetHTTPRequestWasTimedOut";

// ISteamInput
SteamAPI_SteamInput_v002 :: () -> *ISteamInput #foreign steam "SteamAPI_SteamInput_v002";
SteamAPI_ISteamInput_Init :: (self: *ISteamInput) -> bool #foreign steam "SteamAPI_ISteamInput_Init";
SteamAPI_ISteamInput_Shutdown :: (self: *ISteamInput) -> bool #foreign steam "SteamAPI_ISteamInput_Shutdown";
SteamAPI_ISteamInput_RunFrame :: (self: *ISteamInput) #foreign steam "SteamAPI_ISteamInput_RunFrame";
SteamAPI_ISteamInput_GetConnectedControllers :: (self: *ISteamInput, handlesOut: *InputHandle_t) -> s32 #foreign steam "SteamAPI_ISteamInput_GetConnectedControllers";
SteamAPI_ISteamInput_GetActionSetHandle :: (self: *ISteamInput, pszActionSetName: *char) -> InputActionSetHandle_t #foreign steam "SteamAPI_ISteamInput_GetActionSetHandle";
SteamAPI_ISteamInput_ActivateActionSet :: (self: *ISteamInput, inputHandle: InputHandle_t, actionSetHandle: InputActionSetHandle_t) #foreign steam "SteamAPI_ISteamInput_ActivateActionSet";
SteamAPI_ISteamInput_GetCurrentActionSet :: (self: *ISteamInput, inputHandle: InputHandle_t) -> InputActionSetHandle_t #foreign steam "SteamAPI_ISteamInput_GetCurrentActionSet";
SteamAPI_ISteamInput_ActivateActionSetLayer :: (self: *ISteamInput, inputHandle: InputHandle_t, actionSetLayerHandle: InputActionSetHandle_t) #foreign steam "SteamAPI_ISteamInput_ActivateActionSetLayer";
SteamAPI_ISteamInput_DeactivateActionSetLayer :: (self: *ISteamInput, inputHandle: InputHandle_t, actionSetLayerHandle: InputActionSetHandle_t) #foreign steam "SteamAPI_ISteamInput_DeactivateActionSetLayer";
SteamAPI_ISteamInput_DeactivateAllActionSetLayers :: (self: *ISteamInput, inputHandle: InputHandle_t) #foreign steam "SteamAPI_ISteamInput_DeactivateAllActionSetLayers";
SteamAPI_ISteamInput_GetActiveActionSetLayers :: (self: *ISteamInput, inputHandle: InputHandle_t, handlesOut: *InputActionSetHandle_t) -> s32 #foreign steam "SteamAPI_ISteamInput_GetActiveActionSetLayers";
SteamAPI_ISteamInput_GetDigitalActionHandle :: (self: *ISteamInput, pszActionName: *char) -> InputDigitalActionHandle_t #foreign steam "SteamAPI_ISteamInput_GetDigitalActionHandle";
SteamAPI_ISteamInput_GetDigitalActionData :: (self: *ISteamInput, inputHandle: InputHandle_t, digitalActionHandle: InputDigitalActionHandle_t) -> InputDigitalActionData_t #foreign steam "SteamAPI_ISteamInput_GetDigitalActionData";
SteamAPI_ISteamInput_GetDigitalActionOrigins :: (self: *ISteamInput, inputHandle: InputHandle_t, actionSetHandle: InputActionSetHandle_t, digitalActionHandle: InputDigitalActionHandle_t, originsOut: *EInputActionOrigin) -> s32 #foreign steam "SteamAPI_ISteamInput_GetDigitalActionOrigins";
SteamAPI_ISteamInput_GetAnalogActionHandle :: (self: *ISteamInput, pszActionName: *char) -> InputAnalogActionHandle_t #foreign steam "SteamAPI_ISteamInput_GetAnalogActionHandle";
SteamAPI_ISteamInput_GetAnalogActionData :: (self: *ISteamInput, inputHandle: InputHandle_t, analogActionHandle: InputAnalogActionHandle_t) -> InputAnalogActionData_t #foreign steam "SteamAPI_ISteamInput_GetAnalogActionData";
SteamAPI_ISteamInput_GetAnalogActionOrigins :: (self: *ISteamInput, inputHandle: InputHandle_t, actionSetHandle: InputActionSetHandle_t, analogActionHandle: InputAnalogActionHandle_t, originsOut: *EInputActionOrigin) -> s32 #foreign steam "SteamAPI_ISteamInput_GetAnalogActionOrigins";
SteamAPI_ISteamInput_GetGlyphForActionOrigin :: (self: *ISteamInput, eOrigin: EInputActionOrigin) -> *char #foreign steam "SteamAPI_ISteamInput_GetGlyphForActionOrigin";
SteamAPI_ISteamInput_GetStringForActionOrigin :: (self: *ISteamInput, eOrigin: EInputActionOrigin) -> *char #foreign steam "SteamAPI_ISteamInput_GetStringForActionOrigin";
SteamAPI_ISteamInput_StopAnalogActionMomentum :: (self: *ISteamInput, inputHandle: InputHandle_t, eAction: InputAnalogActionHandle_t) #foreign steam "SteamAPI_ISteamInput_StopAnalogActionMomentum";
SteamAPI_ISteamInput_GetMotionData :: (self: *ISteamInput, inputHandle: InputHandle_t) -> InputMotionData_t #foreign steam "SteamAPI_ISteamInput_GetMotionData";
SteamAPI_ISteamInput_TriggerVibration :: (self: *ISteamInput, inputHandle: InputHandle_t, usLeftSpeed: u16, usRightSpeed: u16) #foreign steam "SteamAPI_ISteamInput_TriggerVibration";
SteamAPI_ISteamInput_SetLEDColor :: (self: *ISteamInput, inputHandle: InputHandle_t, nColorR: uint8, nColorG: uint8, nColorB: uint8, nFlags: u32) #foreign steam "SteamAPI_ISteamInput_SetLEDColor";
SteamAPI_ISteamInput_TriggerHapticPulse :: (self: *ISteamInput, inputHandle: InputHandle_t, eTargetPad: ESteamControllerPad, usDurationMicroSec: u16) #foreign steam "SteamAPI_ISteamInput_TriggerHapticPulse";
SteamAPI_ISteamInput_TriggerRepeatedHapticPulse :: (self: *ISteamInput, inputHandle: InputHandle_t, eTargetPad: ESteamControllerPad, usDurationMicroSec: u16, usOffMicroSec: u16, unRepeat: u16, nFlags: u32) #foreign steam "SteamAPI_ISteamInput_TriggerRepeatedHapticPulse";
SteamAPI_ISteamInput_ShowBindingPanel :: (self: *ISteamInput, inputHandle: InputHandle_t) -> bool #foreign steam "SteamAPI_ISteamInput_ShowBindingPanel";
SteamAPI_ISteamInput_GetInputTypeForHandle :: (self: *ISteamInput, inputHandle: InputHandle_t) -> ESteamInputType #foreign steam "SteamAPI_ISteamInput_GetInputTypeForHandle";
SteamAPI_ISteamInput_GetControllerForGamepadIndex :: (self: *ISteamInput, nIndex: s32) -> InputHandle_t #foreign steam "SteamAPI_ISteamInput_GetControllerForGamepadIndex";
SteamAPI_ISteamInput_GetGamepadIndexForController :: (self: *ISteamInput, ulinputHandle: InputHandle_t) -> s32 #foreign steam "SteamAPI_ISteamInput_GetGamepadIndexForController";
SteamAPI_ISteamInput_GetStringForXboxOrigin :: (self: *ISteamInput, eOrigin: EXboxOrigin) -> *char #foreign steam "SteamAPI_ISteamInput_GetStringForXboxOrigin";
SteamAPI_ISteamInput_GetGlyphForXboxOrigin :: (self: *ISteamInput, eOrigin: EXboxOrigin) -> *char #foreign steam "SteamAPI_ISteamInput_GetGlyphForXboxOrigin";
SteamAPI_ISteamInput_GetActionOriginFromXboxOrigin :: (self: *ISteamInput, inputHandle: InputHandle_t, eOrigin: EXboxOrigin) -> EInputActionOrigin #foreign steam "SteamAPI_ISteamInput_GetActionOriginFromXboxOrigin";
SteamAPI_ISteamInput_TranslateActionOrigin :: (self: *ISteamInput, eDestinationInputType: ESteamInputType, eSourceOrigin: EInputActionOrigin) -> EInputActionOrigin #foreign steam "SteamAPI_ISteamInput_TranslateActionOrigin";
SteamAPI_ISteamInput_GetDeviceBindingRevision :: (self: *ISteamInput, inputHandle: InputHandle_t, pMajor: *s32, pMinor: *s32) -> bool #foreign steam "SteamAPI_ISteamInput_GetDeviceBindingRevision";
SteamAPI_ISteamInput_GetRemotePlaySessionID :: (self: *ISteamInput, inputHandle: InputHandle_t) -> uint32 #foreign steam "SteamAPI_ISteamInput_GetRemotePlaySessionID";

// ISteamController
SteamAPI_SteamController_v008 :: () -> *ISteamController #foreign steam "SteamAPI_SteamController_v008";
SteamAPI_ISteamController_Init :: (self: *ISteamController) -> bool #foreign steam "SteamAPI_ISteamController_Init";
SteamAPI_ISteamController_Shutdown :: (self: *ISteamController) -> bool #foreign steam "SteamAPI_ISteamController_Shutdown";
SteamAPI_ISteamController_RunFrame :: (self: *ISteamController) #foreign steam "SteamAPI_ISteamController_RunFrame";
SteamAPI_ISteamController_GetConnectedControllers :: (self: *ISteamController, handlesOut: *ControllerHandle_t) -> s32 #foreign steam "SteamAPI_ISteamController_GetConnectedControllers";
SteamAPI_ISteamController_GetActionSetHandle :: (self: *ISteamController, pszActionSetName: *char) -> ControllerActionSetHandle_t #foreign steam "SteamAPI_ISteamController_GetActionSetHandle";
SteamAPI_ISteamController_ActivateActionSet :: (self: *ISteamController, controllerHandle: ControllerHandle_t, actionSetHandle: ControllerActionSetHandle_t) #foreign steam "SteamAPI_ISteamController_ActivateActionSet";
SteamAPI_ISteamController_GetCurrentActionSet :: (self: *ISteamController, controllerHandle: ControllerHandle_t) -> ControllerActionSetHandle_t #foreign steam "SteamAPI_ISteamController_GetCurrentActionSet";
SteamAPI_ISteamController_ActivateActionSetLayer :: (self: *ISteamController, controllerHandle: ControllerHandle_t, actionSetLayerHandle: ControllerActionSetHandle_t) #foreign steam "SteamAPI_ISteamController_ActivateActionSetLayer";
SteamAPI_ISteamController_DeactivateActionSetLayer :: (self: *ISteamController, controllerHandle: ControllerHandle_t, actionSetLayerHandle: ControllerActionSetHandle_t) #foreign steam "SteamAPI_ISteamController_DeactivateActionSetLayer";
SteamAPI_ISteamController_DeactivateAllActionSetLayers :: (self: *ISteamController, controllerHandle: ControllerHandle_t) #foreign steam "SteamAPI_ISteamController_DeactivateAllActionSetLayers";
SteamAPI_ISteamController_GetActiveActionSetLayers :: (self: *ISteamController, controllerHandle: ControllerHandle_t, handlesOut: *ControllerActionSetHandle_t) -> s32 #foreign steam "SteamAPI_ISteamController_GetActiveActionSetLayers";
SteamAPI_ISteamController_GetDigitalActionHandle :: (self: *ISteamController, pszActionName: *char) -> ControllerDigitalActionHandle_t #foreign steam "SteamAPI_ISteamController_GetDigitalActionHandle";
SteamAPI_ISteamController_GetDigitalActionData :: (self: *ISteamController, controllerHandle: ControllerHandle_t, digitalActionHandle: ControllerDigitalActionHandle_t) -> InputDigitalActionData_t #foreign steam "SteamAPI_ISteamController_GetDigitalActionData";
SteamAPI_ISteamController_GetDigitalActionOrigins :: (self: *ISteamController, controllerHandle: ControllerHandle_t, actionSetHandle: ControllerActionSetHandle_t, digitalActionHandle: ControllerDigitalActionHandle_t, originsOut: *EControllerActionOrigin) -> s32 #foreign steam "SteamAPI_ISteamController_GetDigitalActionOrigins";
SteamAPI_ISteamController_GetAnalogActionHandle :: (self: *ISteamController, pszActionName: *char) -> ControllerAnalogActionHandle_t #foreign steam "SteamAPI_ISteamController_GetAnalogActionHandle";
SteamAPI_ISteamController_GetAnalogActionData :: (self: *ISteamController, controllerHandle: ControllerHandle_t, analogActionHandle: ControllerAnalogActionHandle_t) -> InputAnalogActionData_t #foreign steam "SteamAPI_ISteamController_GetAnalogActionData";
SteamAPI_ISteamController_GetAnalogActionOrigins :: (self: *ISteamController, controllerHandle: ControllerHandle_t, actionSetHandle: ControllerActionSetHandle_t, analogActionHandle: ControllerAnalogActionHandle_t, originsOut: *EControllerActionOrigin) -> s32 #foreign steam "SteamAPI_ISteamController_GetAnalogActionOrigins";
SteamAPI_ISteamController_GetGlyphForActionOrigin :: (self: *ISteamController, eOrigin: EControllerActionOrigin) -> *char #foreign steam "SteamAPI_ISteamController_GetGlyphForActionOrigin";
SteamAPI_ISteamController_GetStringForActionOrigin :: (self: *ISteamController, eOrigin: EControllerActionOrigin) -> *char #foreign steam "SteamAPI_ISteamController_GetStringForActionOrigin";
SteamAPI_ISteamController_StopAnalogActionMomentum :: (self: *ISteamController, controllerHandle: ControllerHandle_t, eAction: ControllerAnalogActionHandle_t) #foreign steam "SteamAPI_ISteamController_StopAnalogActionMomentum";
SteamAPI_ISteamController_GetMotionData :: (self: *ISteamController, controllerHandle: ControllerHandle_t) -> InputMotionData_t #foreign steam "SteamAPI_ISteamController_GetMotionData";
SteamAPI_ISteamController_TriggerHapticPulse :: (self: *ISteamController, controllerHandle: ControllerHandle_t, eTargetPad: ESteamControllerPad, usDurationMicroSec: u16) #foreign steam "SteamAPI_ISteamController_TriggerHapticPulse";
SteamAPI_ISteamController_TriggerRepeatedHapticPulse :: (self: *ISteamController, controllerHandle: ControllerHandle_t, eTargetPad: ESteamControllerPad, usDurationMicroSec: u16, usOffMicroSec: u16, unRepeat: u16, nFlags: u32) #foreign steam "SteamAPI_ISteamController_TriggerRepeatedHapticPulse";
SteamAPI_ISteamController_TriggerVibration :: (self: *ISteamController, controllerHandle: ControllerHandle_t, usLeftSpeed: u16, usRightSpeed: u16) #foreign steam "SteamAPI_ISteamController_TriggerVibration";
SteamAPI_ISteamController_SetLEDColor :: (self: *ISteamController, controllerHandle: ControllerHandle_t, nColorR: uint8, nColorG: uint8, nColorB: uint8, nFlags: u32) #foreign steam "SteamAPI_ISteamController_SetLEDColor";
SteamAPI_ISteamController_ShowBindingPanel :: (self: *ISteamController, controllerHandle: ControllerHandle_t) -> bool #foreign steam "SteamAPI_ISteamController_ShowBindingPanel";
SteamAPI_ISteamController_GetInputTypeForHandle :: (self: *ISteamController, controllerHandle: ControllerHandle_t) -> ESteamInputType #foreign steam "SteamAPI_ISteamController_GetInputTypeForHandle";
SteamAPI_ISteamController_GetControllerForGamepadIndex :: (self: *ISteamController, nIndex: s32) -> ControllerHandle_t #foreign steam "SteamAPI_ISteamController_GetControllerForGamepadIndex";
SteamAPI_ISteamController_GetGamepadIndexForController :: (self: *ISteamController, ulControllerHandle: ControllerHandle_t) -> s32 #foreign steam "SteamAPI_ISteamController_GetGamepadIndexForController";
SteamAPI_ISteamController_GetStringForXboxOrigin :: (self: *ISteamController, eOrigin: EXboxOrigin) -> *char #foreign steam "SteamAPI_ISteamController_GetStringForXboxOrigin";
SteamAPI_ISteamController_GetGlyphForXboxOrigin :: (self: *ISteamController, eOrigin: EXboxOrigin) -> *char #foreign steam "SteamAPI_ISteamController_GetGlyphForXboxOrigin";
SteamAPI_ISteamController_GetActionOriginFromXboxOrigin :: (self: *ISteamController, controllerHandle: ControllerHandle_t, eOrigin: EXboxOrigin) -> EControllerActionOrigin #foreign steam "SteamAPI_ISteamController_GetActionOriginFromXboxOrigin";
SteamAPI_ISteamController_TranslateActionOrigin :: (self: *ISteamController, eDestinationInputType: ESteamInputType, eSourceOrigin: EControllerActionOrigin) -> EControllerActionOrigin #foreign steam "SteamAPI_ISteamController_TranslateActionOrigin";
SteamAPI_ISteamController_GetControllerBindingRevision :: (self: *ISteamController, controllerHandle: ControllerHandle_t, pMajor: *s32, pMinor: *s32) -> bool #foreign steam "SteamAPI_ISteamController_GetControllerBindingRevision";

// ISteamUGC
SteamAPI_SteamUGC_v015 :: () -> *ISteamUGC #foreign steam "SteamAPI_SteamUGC_v015";
SteamAPI_SteamGameServerUGC_v015 :: () -> *ISteamUGC #foreign steam "SteamAPI_SteamGameServerUGC_v015";
SteamAPI_ISteamUGC_CreateQueryUserUGCRequest :: (self: *ISteamUGC, unAccountID: AccountID_t, eListType: EUserUGCList, eMatchingUGCType: EUGCMatchingUGCType, eSortOrder: EUserUGCListSortOrder, nCreatorAppID: AppId_t, nConsumerAppID: AppId_t, unPage: uint32) -> UGCQueryHandle_t #foreign steam "SteamAPI_ISteamUGC_CreateQueryUserUGCRequest";
SteamAPI_ISteamUGC_CreateQueryAllUGCRequestPage :: (self: *ISteamUGC, eQueryType: EUGCQuery, eMatchingeMatchingUGCTypeFileType: EUGCMatchingUGCType, nCreatorAppID: AppId_t, nConsumerAppID: AppId_t, unPage: uint32) -> UGCQueryHandle_t #foreign steam "SteamAPI_ISteamUGC_CreateQueryAllUGCRequestPage";
SteamAPI_ISteamUGC_CreateQueryAllUGCRequestCursor :: (self: *ISteamUGC, eQueryType: EUGCQuery, eMatchingeMatchingUGCTypeFileType: EUGCMatchingUGCType, nCreatorAppID: AppId_t, nConsumerAppID: AppId_t, pchCursor: *char) -> UGCQueryHandle_t #foreign steam "SteamAPI_ISteamUGC_CreateQueryAllUGCRequestCursor";
SteamAPI_ISteamUGC_CreateQueryUGCDetailsRequest :: (self: *ISteamUGC, pvecPublishedFileID: *PublishedFileId_t, unNumPublishedFileIDs: uint32) -> UGCQueryHandle_t #foreign steam "SteamAPI_ISteamUGC_CreateQueryUGCDetailsRequest";
SteamAPI_ISteamUGC_SendQueryUGCRequest :: (self: *ISteamUGC, handle: UGCQueryHandle_t) -> SteamAPICall_t #must #foreign steam "SteamAPI_ISteamUGC_SendQueryUGCRequest";
SteamAPI_ISteamUGC_GetQueryUGCResult :: (self: *ISteamUGC, handle: UGCQueryHandle_t, index: uint32, pDetails: *SteamUGCDetails_t) -> bool #foreign steam "SteamAPI_ISteamUGC_GetQueryUGCResult";
SteamAPI_ISteamUGC_GetQueryUGCNumTags :: (self: *ISteamUGC, handle: UGCQueryHandle_t, index: uint32) -> uint32 #foreign steam "SteamAPI_ISteamUGC_GetQueryUGCNumTags";
SteamAPI_ISteamUGC_GetQueryUGCTag :: (self: *ISteamUGC, handle: UGCQueryHandle_t, index: uint32, indexTag: uint32, pchValue: *char, cchValueSize: uint32) -> bool #foreign steam "SteamAPI_ISteamUGC_GetQueryUGCTag";
SteamAPI_ISteamUGC_GetQueryUGCTagDisplayName :: (self: *ISteamUGC, handle: UGCQueryHandle_t, index: uint32, indexTag: uint32, pchValue: *char, cchValueSize: uint32) -> bool #foreign steam "SteamAPI_ISteamUGC_GetQueryUGCTagDisplayName";
SteamAPI_ISteamUGC_GetQueryUGCPreviewURL :: (self: *ISteamUGC, handle: UGCQueryHandle_t, index: uint32, pchURL: *char, cchURLSize: uint32) -> bool #foreign steam "SteamAPI_ISteamUGC_GetQueryUGCPreviewURL";
SteamAPI_ISteamUGC_GetQueryUGCMetadata :: (self: *ISteamUGC, handle: UGCQueryHandle_t, index: uint32, pchMetadata: *char, cchMetadatasize: uint32) -> bool #foreign steam "SteamAPI_ISteamUGC_GetQueryUGCMetadata";
SteamAPI_ISteamUGC_GetQueryUGCChildren :: (self: *ISteamUGC, handle: UGCQueryHandle_t, index: uint32, pvecPublishedFileID: *PublishedFileId_t, cMaxEntries: uint32) -> bool #foreign steam "SteamAPI_ISteamUGC_GetQueryUGCChildren";
SteamAPI_ISteamUGC_GetQueryUGCStatistic :: (self: *ISteamUGC, handle: UGCQueryHandle_t, index: uint32, eStatType: EItemStatistic, pStatValue: *uint64) -> bool #foreign steam "SteamAPI_ISteamUGC_GetQueryUGCStatistic";
SteamAPI_ISteamUGC_GetQueryUGCNumAdditionalPreviews :: (self: *ISteamUGC, handle: UGCQueryHandle_t, index: uint32) -> uint32 #foreign steam "SteamAPI_ISteamUGC_GetQueryUGCNumAdditionalPreviews";
SteamAPI_ISteamUGC_GetQueryUGCAdditionalPreview :: (self: *ISteamUGC, handle: UGCQueryHandle_t, index: uint32, previewIndex: uint32, pchURLOrVideoID: *char, cchURLSize: uint32, pchOriginalFileName: *char, cchOriginalFileNameSize: uint32, pPreviewType: *EItemPreviewType) -> bool #foreign steam "SteamAPI_ISteamUGC_GetQueryUGCAdditionalPreview";
SteamAPI_ISteamUGC_GetQueryUGCNumKeyValueTags :: (self: *ISteamUGC, handle: UGCQueryHandle_t, index: uint32) -> uint32 #foreign steam "SteamAPI_ISteamUGC_GetQueryUGCNumKeyValueTags";
SteamAPI_ISteamUGC_GetQueryUGCKeyValueTag :: (self: *ISteamUGC, handle: UGCQueryHandle_t, index: uint32, keyValueTagIndex: uint32, pchKey: *char, cchKeySize: uint32, pchValue: *char, cchValueSize: uint32) -> bool #foreign steam "SteamAPI_ISteamUGC_GetQueryUGCKeyValueTag";
SteamAPI_ISteamUGC_GetQueryFirstUGCKeyValueTag :: (self: *ISteamUGC, handle: UGCQueryHandle_t, index: uint32, pchKey: *char, pchValue: *char, cchValueSize: uint32) -> bool #foreign steam "SteamAPI_ISteamUGC_GetQueryFirstUGCKeyValueTag";
SteamAPI_ISteamUGC_ReleaseQueryUGCRequest :: (self: *ISteamUGC, handle: UGCQueryHandle_t) -> bool #foreign steam "SteamAPI_ISteamUGC_ReleaseQueryUGCRequest";
SteamAPI_ISteamUGC_AddRequiredTag :: (self: *ISteamUGC, handle: UGCQueryHandle_t, pTagName: *char) -> bool #foreign steam "SteamAPI_ISteamUGC_AddRequiredTag";
SteamAPI_ISteamUGC_AddRequiredTagGroup :: (self: *ISteamUGC, handle: UGCQueryHandle_t, pTagGroups: *SteamParamStringArray_t) -> bool #foreign steam "SteamAPI_ISteamUGC_AddRequiredTagGroup";
SteamAPI_ISteamUGC_AddExcludedTag :: (self: *ISteamUGC, handle: UGCQueryHandle_t, pTagName: *char) -> bool #foreign steam "SteamAPI_ISteamUGC_AddExcludedTag";
SteamAPI_ISteamUGC_SetReturnOnlyIDs :: (self: *ISteamUGC, handle: UGCQueryHandle_t, bReturnOnlyIDs: bool) -> bool #foreign steam "SteamAPI_ISteamUGC_SetReturnOnlyIDs";
SteamAPI_ISteamUGC_SetReturnKeyValueTags :: (self: *ISteamUGC, handle: UGCQueryHandle_t, bReturnKeyValueTags: bool) -> bool #foreign steam "SteamAPI_ISteamUGC_SetReturnKeyValueTags";
SteamAPI_ISteamUGC_SetReturnLongDescription :: (self: *ISteamUGC, handle: UGCQueryHandle_t, bReturnLongDescription: bool) -> bool #foreign steam "SteamAPI_ISteamUGC_SetReturnLongDescription";
SteamAPI_ISteamUGC_SetReturnMetadata :: (self: *ISteamUGC, handle: UGCQueryHandle_t, bReturnMetadata: bool) -> bool #foreign steam "SteamAPI_ISteamUGC_SetReturnMetadata";
SteamAPI_ISteamUGC_SetReturnChildren :: (self: *ISteamUGC, handle: UGCQueryHandle_t, bReturnChildren: bool) -> bool #foreign steam "SteamAPI_ISteamUGC_SetReturnChildren";
SteamAPI_ISteamUGC_SetReturnAdditionalPreviews :: (self: *ISteamUGC, handle: UGCQueryHandle_t, bReturnAdditionalPreviews: bool) -> bool #foreign steam "SteamAPI_ISteamUGC_SetReturnAdditionalPreviews";
SteamAPI_ISteamUGC_SetReturnTotalOnly :: (self: *ISteamUGC, handle: UGCQueryHandle_t, bReturnTotalOnly: bool) -> bool #foreign steam "SteamAPI_ISteamUGC_SetReturnTotalOnly";
SteamAPI_ISteamUGC_SetReturnPlaytimeStats :: (self: *ISteamUGC, handle: UGCQueryHandle_t, unDays: uint32) -> bool #foreign steam "SteamAPI_ISteamUGC_SetReturnPlaytimeStats";
SteamAPI_ISteamUGC_SetLanguage :: (self: *ISteamUGC, handle: UGCQueryHandle_t, pchLanguage: *char) -> bool #foreign steam "SteamAPI_ISteamUGC_SetLanguage";
SteamAPI_ISteamUGC_SetAllowCachedResponse :: (self: *ISteamUGC, handle: UGCQueryHandle_t, unMaxAgeSeconds: uint32) -> bool #foreign steam "SteamAPI_ISteamUGC_SetAllowCachedResponse";
SteamAPI_ISteamUGC_SetCloudFileNameFilter :: (self: *ISteamUGC, handle: UGCQueryHandle_t, pMatchCloudFileName: *char) -> bool #foreign steam "SteamAPI_ISteamUGC_SetCloudFileNameFilter";
SteamAPI_ISteamUGC_SetMatchAnyTag :: (self: *ISteamUGC, handle: UGCQueryHandle_t, bMatchAnyTag: bool) -> bool #foreign steam "SteamAPI_ISteamUGC_SetMatchAnyTag";
SteamAPI_ISteamUGC_SetSearchText :: (self: *ISteamUGC, handle: UGCQueryHandle_t, pSearchText: *char) -> bool #foreign steam "SteamAPI_ISteamUGC_SetSearchText";
SteamAPI_ISteamUGC_SetRankedByTrendDays :: (self: *ISteamUGC, handle: UGCQueryHandle_t, unDays: uint32) -> bool #foreign steam "SteamAPI_ISteamUGC_SetRankedByTrendDays";
SteamAPI_ISteamUGC_AddRequiredKeyValueTag :: (self: *ISteamUGC, handle: UGCQueryHandle_t, pKey: *char, pValue: *char) -> bool #foreign steam "SteamAPI_ISteamUGC_AddRequiredKeyValueTag";
SteamAPI_ISteamUGC_RequestUGCDetails :: (self: *ISteamUGC, nPublishedFileID: PublishedFileId_t, unMaxAgeSeconds: uint32) -> SteamAPICall_t #must #foreign steam "SteamAPI_ISteamUGC_RequestUGCDetails";
SteamAPI_ISteamUGC_CreateItem :: (self: *ISteamUGC, nConsumerAppId: AppId_t, eFileType: EWorkshopFileType) -> SteamAPICall_t #must #foreign steam "SteamAPI_ISteamUGC_CreateItem";
SteamAPI_ISteamUGC_StartItemUpdate :: (self: *ISteamUGC, nConsumerAppId: AppId_t, nPublishedFileID: PublishedFileId_t) -> UGCUpdateHandle_t #foreign steam "SteamAPI_ISteamUGC_StartItemUpdate";
SteamAPI_ISteamUGC_SetItemTitle :: (self: *ISteamUGC, handle: UGCUpdateHandle_t, pchTitle: *char) -> bool #foreign steam "SteamAPI_ISteamUGC_SetItemTitle";
SteamAPI_ISteamUGC_SetItemDescription :: (self: *ISteamUGC, handle: UGCUpdateHandle_t, pchDescription: *char) -> bool #foreign steam "SteamAPI_ISteamUGC_SetItemDescription";
SteamAPI_ISteamUGC_SetItemUpdateLanguage :: (self: *ISteamUGC, handle: UGCUpdateHandle_t, pchLanguage: *char) -> bool #foreign steam "SteamAPI_ISteamUGC_SetItemUpdateLanguage";
SteamAPI_ISteamUGC_SetItemMetadata :: (self: *ISteamUGC, handle: UGCUpdateHandle_t, pchMetaData: *char) -> bool #foreign steam "SteamAPI_ISteamUGC_SetItemMetadata";
SteamAPI_ISteamUGC_SetItemVisibility :: (self: *ISteamUGC, handle: UGCUpdateHandle_t, eVisibility: ERemoteStoragePublishedFileVisibility) -> bool #foreign steam "SteamAPI_ISteamUGC_SetItemVisibility";
SteamAPI_ISteamUGC_SetItemTags :: (self: *ISteamUGC, updateHandle: UGCUpdateHandle_t, pTags: *SteamParamStringArray_t) -> bool #foreign steam "SteamAPI_ISteamUGC_SetItemTags";
SteamAPI_ISteamUGC_SetItemContent :: (self: *ISteamUGC, handle: UGCUpdateHandle_t, pszContentFolder: *char) -> bool #foreign steam "SteamAPI_ISteamUGC_SetItemContent";
SteamAPI_ISteamUGC_SetItemPreview :: (self: *ISteamUGC, handle: UGCUpdateHandle_t, pszPreviewFile: *char) -> bool #foreign steam "SteamAPI_ISteamUGC_SetItemPreview";
SteamAPI_ISteamUGC_SetAllowLegacyUpload :: (self: *ISteamUGC, handle: UGCUpdateHandle_t, bAllowLegacyUpload: bool) -> bool #foreign steam "SteamAPI_ISteamUGC_SetAllowLegacyUpload";
SteamAPI_ISteamUGC_RemoveAllItemKeyValueTags :: (self: *ISteamUGC, handle: UGCUpdateHandle_t) -> bool #foreign steam "SteamAPI_ISteamUGC_RemoveAllItemKeyValueTags";
SteamAPI_ISteamUGC_RemoveItemKeyValueTags :: (self: *ISteamUGC, handle: UGCUpdateHandle_t, pchKey: *char) -> bool #foreign steam "SteamAPI_ISteamUGC_RemoveItemKeyValueTags";
SteamAPI_ISteamUGC_AddItemKeyValueTag :: (self: *ISteamUGC, handle: UGCUpdateHandle_t, pchKey: *char, pchValue: *char) -> bool #foreign steam "SteamAPI_ISteamUGC_AddItemKeyValueTag";
SteamAPI_ISteamUGC_AddItemPreviewFile :: (self: *ISteamUGC, handle: UGCUpdateHandle_t, pszPreviewFile: *char, type: EItemPreviewType) -> bool #foreign steam "SteamAPI_ISteamUGC_AddItemPreviewFile";
SteamAPI_ISteamUGC_AddItemPreviewVideo :: (self: *ISteamUGC, handle: UGCUpdateHandle_t, pszVideoID: *char) -> bool #foreign steam "SteamAPI_ISteamUGC_AddItemPreviewVideo";
SteamAPI_ISteamUGC_UpdateItemPreviewFile :: (self: *ISteamUGC, handle: UGCUpdateHandle_t, index: uint32, pszPreviewFile: *char) -> bool #foreign steam "SteamAPI_ISteamUGC_UpdateItemPreviewFile";
SteamAPI_ISteamUGC_UpdateItemPreviewVideo :: (self: *ISteamUGC, handle: UGCUpdateHandle_t, index: uint32, pszVideoID: *char) -> bool #foreign steam "SteamAPI_ISteamUGC_UpdateItemPreviewVideo";
SteamAPI_ISteamUGC_RemoveItemPreview :: (self: *ISteamUGC, handle: UGCUpdateHandle_t, index: uint32) -> bool #foreign steam "SteamAPI_ISteamUGC_RemoveItemPreview";
SteamAPI_ISteamUGC_SubmitItemUpdate :: (self: *ISteamUGC, handle: UGCUpdateHandle_t, pchChangeNote: *char) -> SteamAPICall_t #must #foreign steam "SteamAPI_ISteamUGC_SubmitItemUpdate";
SteamAPI_ISteamUGC_GetItemUpdateProgress :: (self: *ISteamUGC, handle: UGCUpdateHandle_t, punBytesProcessed: *uint64, punBytesTotal: *uint64) -> EItemUpdateStatus #foreign steam "SteamAPI_ISteamUGC_GetItemUpdateProgress";
SteamAPI_ISteamUGC_SetUserItemVote :: (self: *ISteamUGC, nPublishedFileID: PublishedFileId_t, bVoteUp: bool) -> SteamAPICall_t #must #foreign steam "SteamAPI_ISteamUGC_SetUserItemVote";
SteamAPI_ISteamUGC_GetUserItemVote :: (self: *ISteamUGC, nPublishedFileID: PublishedFileId_t) -> SteamAPICall_t #must #foreign steam "SteamAPI_ISteamUGC_GetUserItemVote";
SteamAPI_ISteamUGC_AddItemToFavorites :: (self: *ISteamUGC, nAppId: AppId_t, nPublishedFileID: PublishedFileId_t) -> SteamAPICall_t #must #foreign steam "SteamAPI_ISteamUGC_AddItemToFavorites";
SteamAPI_ISteamUGC_RemoveItemFromFavorites :: (self: *ISteamUGC, nAppId: AppId_t, nPublishedFileID: PublishedFileId_t) -> SteamAPICall_t #must #foreign steam "SteamAPI_ISteamUGC_RemoveItemFromFavorites";
SteamAPI_ISteamUGC_SubscribeItem :: (self: *ISteamUGC, nPublishedFileID: PublishedFileId_t) -> SteamAPICall_t #must #foreign steam "SteamAPI_ISteamUGC_SubscribeItem";
SteamAPI_ISteamUGC_UnsubscribeItem :: (self: *ISteamUGC, nPublishedFileID: PublishedFileId_t) -> SteamAPICall_t #must #foreign steam "SteamAPI_ISteamUGC_UnsubscribeItem";
SteamAPI_ISteamUGC_GetNumSubscribedItems :: (self: *ISteamUGC) -> uint32 #foreign steam "SteamAPI_ISteamUGC_GetNumSubscribedItems";
SteamAPI_ISteamUGC_GetSubscribedItems :: (self: *ISteamUGC, pvecPublishedFileID: *PublishedFileId_t, cMaxEntries: uint32) -> uint32 #foreign steam "SteamAPI_ISteamUGC_GetSubscribedItems";
SteamAPI_ISteamUGC_GetItemState :: (self: *ISteamUGC, nPublishedFileID: PublishedFileId_t) -> uint32 #foreign steam "SteamAPI_ISteamUGC_GetItemState";
SteamAPI_ISteamUGC_GetItemInstallInfo :: (self: *ISteamUGC, nPublishedFileID: PublishedFileId_t, punSizeOnDisk: *uint64, pchFolder: *char, cchFolderSize: uint32, punTimeStamp: *uint32) -> bool #foreign steam "SteamAPI_ISteamUGC_GetItemInstallInfo";
SteamAPI_ISteamUGC_GetItemDownloadInfo :: (self: *ISteamUGC, nPublishedFileID: PublishedFileId_t, punBytesDownloaded: *uint64, punBytesTotal: *uint64) -> bool #foreign steam "SteamAPI_ISteamUGC_GetItemDownloadInfo";
SteamAPI_ISteamUGC_DownloadItem :: (self: *ISteamUGC, nPublishedFileID: PublishedFileId_t, bHighPriority: bool) -> bool #foreign steam "SteamAPI_ISteamUGC_DownloadItem";
SteamAPI_ISteamUGC_BInitWorkshopForGameServer :: (self: *ISteamUGC, unWorkshopDepotID: DepotId_t, pszFolder: *char) -> bool #foreign steam "SteamAPI_ISteamUGC_BInitWorkshopForGameServer";
SteamAPI_ISteamUGC_SuspendDownloads :: (self: *ISteamUGC, bSuspend: bool) #foreign steam "SteamAPI_ISteamUGC_SuspendDownloads";
SteamAPI_ISteamUGC_StartPlaytimeTracking :: (self: *ISteamUGC, pvecPublishedFileID: *PublishedFileId_t, unNumPublishedFileIDs: uint32) -> SteamAPICall_t #must #foreign steam "SteamAPI_ISteamUGC_StartPlaytimeTracking";
SteamAPI_ISteamUGC_StopPlaytimeTracking :: (self: *ISteamUGC, pvecPublishedFileID: *PublishedFileId_t, unNumPublishedFileIDs: uint32) -> SteamAPICall_t #must #foreign steam "SteamAPI_ISteamUGC_StopPlaytimeTracking";
SteamAPI_ISteamUGC_StopPlaytimeTrackingForAllItems :: (self: *ISteamUGC) -> SteamAPICall_t #must #foreign steam "SteamAPI_ISteamUGC_StopPlaytimeTrackingForAllItems";
SteamAPI_ISteamUGC_AddDependency :: (self: *ISteamUGC, nParentPublishedFileID: PublishedFileId_t, nChildPublishedFileID: PublishedFileId_t) -> SteamAPICall_t #must #foreign steam "SteamAPI_ISteamUGC_AddDependency";
SteamAPI_ISteamUGC_RemoveDependency :: (self: *ISteamUGC, nParentPublishedFileID: PublishedFileId_t, nChildPublishedFileID: PublishedFileId_t) -> SteamAPICall_t #must #foreign steam "SteamAPI_ISteamUGC_RemoveDependency";
SteamAPI_ISteamUGC_AddAppDependency :: (self: *ISteamUGC, nPublishedFileID: PublishedFileId_t, nAppID: AppId_t) -> SteamAPICall_t #must #foreign steam "SteamAPI_ISteamUGC_AddAppDependency";
SteamAPI_ISteamUGC_RemoveAppDependency :: (self: *ISteamUGC, nPublishedFileID: PublishedFileId_t, nAppID: AppId_t) -> SteamAPICall_t #must #foreign steam "SteamAPI_ISteamUGC_RemoveAppDependency";
SteamAPI_ISteamUGC_GetAppDependencies :: (self: *ISteamUGC, nPublishedFileID: PublishedFileId_t) -> SteamAPICall_t #must #foreign steam "SteamAPI_ISteamUGC_GetAppDependencies";
SteamAPI_ISteamUGC_DeleteItem :: (self: *ISteamUGC, nPublishedFileID: PublishedFileId_t) -> SteamAPICall_t #must #foreign steam "SteamAPI_ISteamUGC_DeleteItem";

// ISteamAppList
SteamAPI_SteamAppList_v001 :: () -> *ISteamAppList #foreign steam "SteamAPI_SteamAppList_v001";
SteamAPI_ISteamAppList_GetNumInstalledApps :: (self: *ISteamAppList) -> uint32 #foreign steam "SteamAPI_ISteamAppList_GetNumInstalledApps";
SteamAPI_ISteamAppList_GetInstalledApps :: (self: *ISteamAppList, pvecAppID: *AppId_t, unMaxAppIDs: uint32) -> uint32 #foreign steam "SteamAPI_ISteamAppList_GetInstalledApps";
SteamAPI_ISteamAppList_GetAppName :: (self: *ISteamAppList, nAppID: AppId_t, pchName: *char, cchNameMax: s32) -> s32 #foreign steam "SteamAPI_ISteamAppList_GetAppName";
SteamAPI_ISteamAppList_GetAppInstallDir :: (self: *ISteamAppList, nAppID: AppId_t, pchDirectory: *char, cchNameMax: s32) -> s32 #foreign steam "SteamAPI_ISteamAppList_GetAppInstallDir";
SteamAPI_ISteamAppList_GetAppBuildId :: (self: *ISteamAppList, nAppID: AppId_t) -> s32 #foreign steam "SteamAPI_ISteamAppList_GetAppBuildId";

// ISteamHTMLSurface
SteamAPI_SteamHTMLSurface_v005 :: () -> *ISteamHTMLSurface #foreign steam "SteamAPI_SteamHTMLSurface_v005";
SteamAPI_ISteamHTMLSurface_Init :: (self: *ISteamHTMLSurface) -> bool #foreign steam "SteamAPI_ISteamHTMLSurface_Init";
SteamAPI_ISteamHTMLSurface_Shutdown :: (self: *ISteamHTMLSurface) -> bool #foreign steam "SteamAPI_ISteamHTMLSurface_Shutdown";
SteamAPI_ISteamHTMLSurface_CreateBrowser :: (self: *ISteamHTMLSurface, pchUserAgent: *char, pchUserCSS: *char) -> SteamAPICall_t #must #foreign steam "SteamAPI_ISteamHTMLSurface_CreateBrowser";
SteamAPI_ISteamHTMLSurface_RemoveBrowser :: (self: *ISteamHTMLSurface, unBrowserHandle: HHTMLBrowser) #foreign steam "SteamAPI_ISteamHTMLSurface_RemoveBrowser";
SteamAPI_ISteamHTMLSurface_LoadURL :: (self: *ISteamHTMLSurface, unBrowserHandle: HHTMLBrowser, pchURL: *char, pchPostData: *char) #foreign steam "SteamAPI_ISteamHTMLSurface_LoadURL";
SteamAPI_ISteamHTMLSurface_SetSize :: (self: *ISteamHTMLSurface, unBrowserHandle: HHTMLBrowser, unWidth: uint32, unHeight: uint32) #foreign steam "SteamAPI_ISteamHTMLSurface_SetSize";
SteamAPI_ISteamHTMLSurface_StopLoad :: (self: *ISteamHTMLSurface, unBrowserHandle: HHTMLBrowser) #foreign steam "SteamAPI_ISteamHTMLSurface_StopLoad";
SteamAPI_ISteamHTMLSurface_Reload :: (self: *ISteamHTMLSurface, unBrowserHandle: HHTMLBrowser) #foreign steam "SteamAPI_ISteamHTMLSurface_Reload";
SteamAPI_ISteamHTMLSurface_GoBack :: (self: *ISteamHTMLSurface, unBrowserHandle: HHTMLBrowser) #foreign steam "SteamAPI_ISteamHTMLSurface_GoBack";
SteamAPI_ISteamHTMLSurface_GoForward :: (self: *ISteamHTMLSurface, unBrowserHandle: HHTMLBrowser) #foreign steam "SteamAPI_ISteamHTMLSurface_GoForward";
SteamAPI_ISteamHTMLSurface_AddHeader :: (self: *ISteamHTMLSurface, unBrowserHandle: HHTMLBrowser, pchKey: *char, pchValue: *char) #foreign steam "SteamAPI_ISteamHTMLSurface_AddHeader";
SteamAPI_ISteamHTMLSurface_ExecuteJavascript :: (self: *ISteamHTMLSurface, unBrowserHandle: HHTMLBrowser, pchScript: *char) #foreign steam "SteamAPI_ISteamHTMLSurface_ExecuteJavascript";
SteamAPI_ISteamHTMLSurface_MouseUp :: (self: *ISteamHTMLSurface, unBrowserHandle: HHTMLBrowser, eMouseButton: EHTMLMouseButton) #foreign steam "SteamAPI_ISteamHTMLSurface_MouseUp";
SteamAPI_ISteamHTMLSurface_MouseDown :: (self: *ISteamHTMLSurface, unBrowserHandle: HHTMLBrowser, eMouseButton: EHTMLMouseButton) #foreign steam "SteamAPI_ISteamHTMLSurface_MouseDown";
SteamAPI_ISteamHTMLSurface_MouseDoubleClick :: (self: *ISteamHTMLSurface, unBrowserHandle: HHTMLBrowser, eMouseButton: EHTMLMouseButton) #foreign steam "SteamAPI_ISteamHTMLSurface_MouseDoubleClick";
SteamAPI_ISteamHTMLSurface_MouseMove :: (self: *ISteamHTMLSurface, unBrowserHandle: HHTMLBrowser, x: s32, y: s32) #foreign steam "SteamAPI_ISteamHTMLSurface_MouseMove";
SteamAPI_ISteamHTMLSurface_MouseWheel :: (self: *ISteamHTMLSurface, unBrowserHandle: HHTMLBrowser, nDelta: int32) #foreign steam "SteamAPI_ISteamHTMLSurface_MouseWheel";
SteamAPI_ISteamHTMLSurface_KeyDown :: (self: *ISteamHTMLSurface, unBrowserHandle: HHTMLBrowser, nNativeKeyCode: uint32, eHTMLKeyModifiers: EHTMLKeyModifiers, bIsSystemKey: bool) #foreign steam "SteamAPI_ISteamHTMLSurface_KeyDown";
SteamAPI_ISteamHTMLSurface_KeyUp :: (self: *ISteamHTMLSurface, unBrowserHandle: HHTMLBrowser, nNativeKeyCode: uint32, eHTMLKeyModifiers: EHTMLKeyModifiers) #foreign steam "SteamAPI_ISteamHTMLSurface_KeyUp";
SteamAPI_ISteamHTMLSurface_KeyChar :: (self: *ISteamHTMLSurface, unBrowserHandle: HHTMLBrowser, cUnicodeChar: uint32, eHTMLKeyModifiers: EHTMLKeyModifiers) #foreign steam "SteamAPI_ISteamHTMLSurface_KeyChar";
SteamAPI_ISteamHTMLSurface_SetHorizontalScroll :: (self: *ISteamHTMLSurface, unBrowserHandle: HHTMLBrowser, nAbsolutePixelScroll: uint32) #foreign steam "SteamAPI_ISteamHTMLSurface_SetHorizontalScroll";
SteamAPI_ISteamHTMLSurface_SetVerticalScroll :: (self: *ISteamHTMLSurface, unBrowserHandle: HHTMLBrowser, nAbsolutePixelScroll: uint32) #foreign steam "SteamAPI_ISteamHTMLSurface_SetVerticalScroll";
SteamAPI_ISteamHTMLSurface_SetKeyFocus :: (self: *ISteamHTMLSurface, unBrowserHandle: HHTMLBrowser, bHasKeyFocus: bool) #foreign steam "SteamAPI_ISteamHTMLSurface_SetKeyFocus";
SteamAPI_ISteamHTMLSurface_ViewSource :: (self: *ISteamHTMLSurface, unBrowserHandle: HHTMLBrowser) #foreign steam "SteamAPI_ISteamHTMLSurface_ViewSource";
SteamAPI_ISteamHTMLSurface_CopyToClipboard :: (self: *ISteamHTMLSurface, unBrowserHandle: HHTMLBrowser) #foreign steam "SteamAPI_ISteamHTMLSurface_CopyToClipboard";
SteamAPI_ISteamHTMLSurface_PasteFromClipboard :: (self: *ISteamHTMLSurface, unBrowserHandle: HHTMLBrowser) #foreign steam "SteamAPI_ISteamHTMLSurface_PasteFromClipboard";
SteamAPI_ISteamHTMLSurface_Find :: (self: *ISteamHTMLSurface, unBrowserHandle: HHTMLBrowser, pchSearchStr: *char, bCurrentlyInFind: bool, bReverse: bool) #foreign steam "SteamAPI_ISteamHTMLSurface_Find";
SteamAPI_ISteamHTMLSurface_StopFind :: (self: *ISteamHTMLSurface, unBrowserHandle: HHTMLBrowser) #foreign steam "SteamAPI_ISteamHTMLSurface_StopFind";
SteamAPI_ISteamHTMLSurface_GetLinkAtPosition :: (self: *ISteamHTMLSurface, unBrowserHandle: HHTMLBrowser, x: s32, y: s32) #foreign steam "SteamAPI_ISteamHTMLSurface_GetLinkAtPosition";
SteamAPI_ISteamHTMLSurface_SetCookie :: (self: *ISteamHTMLSurface, pchHostname: *char, pchKey: *char, pchValue: *char, pchPath: *char, nExpires: RTime32, bSecure: bool, bHTTPOnly: bool) #foreign steam "SteamAPI_ISteamHTMLSurface_SetCookie";
SteamAPI_ISteamHTMLSurface_SetPageScaleFactor :: (self: *ISteamHTMLSurface, unBrowserHandle: HHTMLBrowser, flZoom: float, nPointX: s32, nPointY: s32) #foreign steam "SteamAPI_ISteamHTMLSurface_SetPageScaleFactor";
SteamAPI_ISteamHTMLSurface_SetBackgroundMode :: (self: *ISteamHTMLSurface, unBrowserHandle: HHTMLBrowser, bBackgroundMode: bool) #foreign steam "SteamAPI_ISteamHTMLSurface_SetBackgroundMode";
SteamAPI_ISteamHTMLSurface_SetDPIScalingFactor :: (self: *ISteamHTMLSurface, unBrowserHandle: HHTMLBrowser, flDPIScaling: float) #foreign steam "SteamAPI_ISteamHTMLSurface_SetDPIScalingFactor";
SteamAPI_ISteamHTMLSurface_OpenDeveloperTools :: (self: *ISteamHTMLSurface, unBrowserHandle: HHTMLBrowser) #foreign steam "SteamAPI_ISteamHTMLSurface_OpenDeveloperTools";
SteamAPI_ISteamHTMLSurface_AllowStartRequest :: (self: *ISteamHTMLSurface, unBrowserHandle: HHTMLBrowser, bAllowed: bool) #foreign steam "SteamAPI_ISteamHTMLSurface_AllowStartRequest";
SteamAPI_ISteamHTMLSurface_JSDialogResponse :: (self: *ISteamHTMLSurface, unBrowserHandle: HHTMLBrowser, bResult: bool) #foreign steam "SteamAPI_ISteamHTMLSurface_JSDialogResponse";
SteamAPI_ISteamHTMLSurface_FileLoadDialogResponse :: (self: *ISteamHTMLSurface, unBrowserHandle: HHTMLBrowser, pchSelectedFiles: **char) #foreign steam "SteamAPI_ISteamHTMLSurface_FileLoadDialogResponse";

// ISteamInventory
SteamAPI_SteamInventory_v003 :: () -> *ISteamInventory #foreign steam "SteamAPI_SteamInventory_v003";
SteamAPI_SteamGameServerInventory_v003 :: () -> *ISteamInventory #foreign steam "SteamAPI_SteamGameServerInventory_v003";
SteamAPI_ISteamInventory_GetResultStatus :: (self: *ISteamInventory, resultHandle: SteamInventoryResult_t) -> EResult #foreign steam "SteamAPI_ISteamInventory_GetResultStatus";
SteamAPI_ISteamInventory_GetResultItems :: (self: *ISteamInventory, resultHandle: SteamInventoryResult_t, pOutItemsArray: *SteamItemDetails_t, punOutItemsArraySize: *uint32) -> bool #foreign steam "SteamAPI_ISteamInventory_GetResultItems";
SteamAPI_ISteamInventory_GetResultItemProperty :: (self: *ISteamInventory, resultHandle: SteamInventoryResult_t, unItemIndex: uint32, pchPropertyName: *char, pchValueBuffer: *char, punValueBufferSizeOut: *uint32) -> bool #foreign steam "SteamAPI_ISteamInventory_GetResultItemProperty";
SteamAPI_ISteamInventory_GetResultTimestamp :: (self: *ISteamInventory, resultHandle: SteamInventoryResult_t) -> uint32 #foreign steam "SteamAPI_ISteamInventory_GetResultTimestamp";
SteamAPI_ISteamInventory_CheckResultSteamID :: (self: *ISteamInventory, resultHandle: SteamInventoryResult_t, steamIDExpected: uint64_steamid) -> bool #foreign steam "SteamAPI_ISteamInventory_CheckResultSteamID";
SteamAPI_ISteamInventory_DestroyResult :: (self: *ISteamInventory, resultHandle: SteamInventoryResult_t) #foreign steam "SteamAPI_ISteamInventory_DestroyResult";
SteamAPI_ISteamInventory_GetAllItems :: (self: *ISteamInventory, pResultHandle: *SteamInventoryResult_t) -> bool #foreign steam "SteamAPI_ISteamInventory_GetAllItems";
SteamAPI_ISteamInventory_GetItemsByID :: (self: *ISteamInventory, pResultHandle: *SteamInventoryResult_t, pInstanceIDs: *SteamItemInstanceID_t, unCountInstanceIDs: uint32) -> bool #foreign steam "SteamAPI_ISteamInventory_GetItemsByID";
SteamAPI_ISteamInventory_SerializeResult :: (self: *ISteamInventory, resultHandle: SteamInventoryResult_t, pOutBuffer: *void, punOutBufferSize: *uint32) -> bool #foreign steam "SteamAPI_ISteamInventory_SerializeResult";
SteamAPI_ISteamInventory_DeserializeResult :: (self: *ISteamInventory, pOutResultHandle: *SteamInventoryResult_t, pBuffer: *void, unBufferSize: uint32, bRESERVED_MUST_BE_FALSE: bool) -> bool #foreign steam "SteamAPI_ISteamInventory_DeserializeResult";
SteamAPI_ISteamInventory_GenerateItems :: (self: *ISteamInventory, pResultHandle: *SteamInventoryResult_t, pArrayItemDefs: *SteamItemDef_t, punArrayQuantity: *uint32, unArrayLength: uint32) -> bool #foreign steam "SteamAPI_ISteamInventory_GenerateItems";
SteamAPI_ISteamInventory_GrantPromoItems :: (self: *ISteamInventory, pResultHandle: *SteamInventoryResult_t) -> bool #foreign steam "SteamAPI_ISteamInventory_GrantPromoItems";
SteamAPI_ISteamInventory_AddPromoItem :: (self: *ISteamInventory, pResultHandle: *SteamInventoryResult_t, itemDef: SteamItemDef_t) -> bool #foreign steam "SteamAPI_ISteamInventory_AddPromoItem";
SteamAPI_ISteamInventory_AddPromoItems :: (self: *ISteamInventory, pResultHandle: *SteamInventoryResult_t, pArrayItemDefs: *SteamItemDef_t, unArrayLength: uint32) -> bool #foreign steam "SteamAPI_ISteamInventory_AddPromoItems";
SteamAPI_ISteamInventory_ConsumeItem :: (self: *ISteamInventory, pResultHandle: *SteamInventoryResult_t, itemConsume: SteamItemInstanceID_t, unQuantity: uint32) -> bool #foreign steam "SteamAPI_ISteamInventory_ConsumeItem";
SteamAPI_ISteamInventory_ExchangeItems :: (self: *ISteamInventory, pResultHandle: *SteamInventoryResult_t, pArrayGenerate: *SteamItemDef_t, punArrayGenerateQuantity: *uint32, unArrayGenerateLength: uint32, pArrayDestroy: *SteamItemInstanceID_t, punArrayDestroyQuantity: *uint32, unArrayDestroyLength: uint32) -> bool #foreign steam "SteamAPI_ISteamInventory_ExchangeItems";
SteamAPI_ISteamInventory_TransferItemQuantity :: (self: *ISteamInventory, pResultHandle: *SteamInventoryResult_t, itemIdSource: SteamItemInstanceID_t, unQuantity: uint32, itemIdDest: SteamItemInstanceID_t) -> bool #foreign steam "SteamAPI_ISteamInventory_TransferItemQuantity";
SteamAPI_ISteamInventory_SendItemDropHeartbeat :: (self: *ISteamInventory) #foreign steam "SteamAPI_ISteamInventory_SendItemDropHeartbeat";
SteamAPI_ISteamInventory_TriggerItemDrop :: (self: *ISteamInventory, pResultHandle: *SteamInventoryResult_t, dropListDefinition: SteamItemDef_t) -> bool #foreign steam "SteamAPI_ISteamInventory_TriggerItemDrop";
SteamAPI_ISteamInventory_TradeItems :: (self: *ISteamInventory, pResultHandle: *SteamInventoryResult_t, steamIDTradePartner: uint64_steamid, pArrayGive: *SteamItemInstanceID_t, pArrayGiveQuantity: *uint32, nArrayGiveLength: uint32, pArrayGet: *SteamItemInstanceID_t, pArrayGetQuantity: *uint32, nArrayGetLength: uint32) -> bool #foreign steam "SteamAPI_ISteamInventory_TradeItems";
SteamAPI_ISteamInventory_LoadItemDefinitions :: (self: *ISteamInventory) -> bool #foreign steam "SteamAPI_ISteamInventory_LoadItemDefinitions";
SteamAPI_ISteamInventory_GetItemDefinitionIDs :: (self: *ISteamInventory, pItemDefIDs: *SteamItemDef_t, punItemDefIDsArraySize: *uint32) -> bool #foreign steam "SteamAPI_ISteamInventory_GetItemDefinitionIDs";
SteamAPI_ISteamInventory_GetItemDefinitionProperty :: (self: *ISteamInventory, iDefinition: SteamItemDef_t, pchPropertyName: *char, pchValueBuffer: *char, punValueBufferSizeOut: *uint32) -> bool #foreign steam "SteamAPI_ISteamInventory_GetItemDefinitionProperty";
SteamAPI_ISteamInventory_RequestEligiblePromoItemDefinitionsIDs :: (self: *ISteamInventory, steamID: uint64_steamid) -> SteamAPICall_t #must #foreign steam "SteamAPI_ISteamInventory_RequestEligiblePromoItemDefinitionsIDs";
SteamAPI_ISteamInventory_GetEligiblePromoItemDefinitionIDs :: (self: *ISteamInventory, steamID: uint64_steamid, pItemDefIDs: *SteamItemDef_t, punItemDefIDsArraySize: *uint32) -> bool #foreign steam "SteamAPI_ISteamInventory_GetEligiblePromoItemDefinitionIDs";
SteamAPI_ISteamInventory_StartPurchase :: (self: *ISteamInventory, pArrayItemDefs: *SteamItemDef_t, punArrayQuantity: *uint32, unArrayLength: uint32) -> SteamAPICall_t #must #foreign steam "SteamAPI_ISteamInventory_StartPurchase";
SteamAPI_ISteamInventory_RequestPrices :: (self: *ISteamInventory) -> SteamAPICall_t #must #foreign steam "SteamAPI_ISteamInventory_RequestPrices";
SteamAPI_ISteamInventory_GetNumItemsWithPrices :: (self: *ISteamInventory) -> uint32 #foreign steam "SteamAPI_ISteamInventory_GetNumItemsWithPrices";
SteamAPI_ISteamInventory_GetItemsWithPrices :: (self: *ISteamInventory, pArrayItemDefs: *SteamItemDef_t, pCurrentPrices: *uint64, pBasePrices: *uint64, unArrayLength: uint32) -> bool #foreign steam "SteamAPI_ISteamInventory_GetItemsWithPrices";
SteamAPI_ISteamInventory_GetItemPrice :: (self: *ISteamInventory, iDefinition: SteamItemDef_t, pCurrentPrice: *uint64, pBasePrice: *uint64) -> bool #foreign steam "SteamAPI_ISteamInventory_GetItemPrice";
SteamAPI_ISteamInventory_StartUpdateProperties :: (self: *ISteamInventory) -> SteamInventoryUpdateHandle_t #foreign steam "SteamAPI_ISteamInventory_StartUpdateProperties";
SteamAPI_ISteamInventory_RemoveProperty :: (self: *ISteamInventory, handle: SteamInventoryUpdateHandle_t, nItemID: SteamItemInstanceID_t, pchPropertyName: *char) -> bool #foreign steam "SteamAPI_ISteamInventory_RemoveProperty";
SteamAPI_ISteamInventory_SetPropertyString :: (self: *ISteamInventory, handle: SteamInventoryUpdateHandle_t, nItemID: SteamItemInstanceID_t, pchPropertyName: *char, pchPropertyValue: *char) -> bool #foreign steam "SteamAPI_ISteamInventory_SetPropertyString";
SteamAPI_ISteamInventory_SetPropertyBool :: (self: *ISteamInventory, handle: SteamInventoryUpdateHandle_t, nItemID: SteamItemInstanceID_t, pchPropertyName: *char, bValue: bool) -> bool #foreign steam "SteamAPI_ISteamInventory_SetPropertyBool";
SteamAPI_ISteamInventory_SetPropertyInt64 :: (self: *ISteamInventory, handle: SteamInventoryUpdateHandle_t, nItemID: SteamItemInstanceID_t, pchPropertyName: *char, nValue: int64) -> bool #foreign steam "SteamAPI_ISteamInventory_SetPropertyInt64";
SteamAPI_ISteamInventory_SetPropertyFloat :: (self: *ISteamInventory, handle: SteamInventoryUpdateHandle_t, nItemID: SteamItemInstanceID_t, pchPropertyName: *char, flValue: float) -> bool #foreign steam "SteamAPI_ISteamInventory_SetPropertyFloat";
SteamAPI_ISteamInventory_SubmitUpdateProperties :: (self: *ISteamInventory, handle: SteamInventoryUpdateHandle_t, pResultHandle: *SteamInventoryResult_t) -> bool #foreign steam "SteamAPI_ISteamInventory_SubmitUpdateProperties";
SteamAPI_ISteamInventory_InspectItem :: (self: *ISteamInventory, pResultHandle: *SteamInventoryResult_t, pchItemToken: *char) -> bool #foreign steam "SteamAPI_ISteamInventory_InspectItem";

// ISteamVideo
SteamAPI_SteamVideo_v002 :: () -> *ISteamVideo #foreign steam "SteamAPI_SteamVideo_v002";
SteamAPI_ISteamVideo_GetVideoURL :: (self: *ISteamVideo, unVideoAppID: AppId_t) #foreign steam "SteamAPI_ISteamVideo_GetVideoURL";
SteamAPI_ISteamVideo_IsBroadcasting :: (self: *ISteamVideo, pnNumViewers: *s32) -> bool #foreign steam "SteamAPI_ISteamVideo_IsBroadcasting";
SteamAPI_ISteamVideo_GetOPFSettings :: (self: *ISteamVideo, unVideoAppID: AppId_t) #foreign steam "SteamAPI_ISteamVideo_GetOPFSettings";
SteamAPI_ISteamVideo_GetOPFStringForApp :: (self: *ISteamVideo, unVideoAppID: AppId_t, pchBuffer: *char, pnBufferSize: *int32) -> bool #foreign steam "SteamAPI_ISteamVideo_GetOPFStringForApp";

// ISteamParentalSettings
SteamAPI_SteamParentalSettings_v001 :: () -> *ISteamParentalSettings #foreign steam "SteamAPI_SteamParentalSettings_v001";
SteamAPI_ISteamParentalSettings_BIsParentalLockEnabled :: (self: *ISteamParentalSettings) -> bool #foreign steam "SteamAPI_ISteamParentalSettings_BIsParentalLockEnabled";
SteamAPI_ISteamParentalSettings_BIsParentalLockLocked :: (self: *ISteamParentalSettings) -> bool #foreign steam "SteamAPI_ISteamParentalSettings_BIsParentalLockLocked";
SteamAPI_ISteamParentalSettings_BIsAppBlocked :: (self: *ISteamParentalSettings, nAppID: AppId_t) -> bool #foreign steam "SteamAPI_ISteamParentalSettings_BIsAppBlocked";
SteamAPI_ISteamParentalSettings_BIsAppInBlockList :: (self: *ISteamParentalSettings, nAppID: AppId_t) -> bool #foreign steam "SteamAPI_ISteamParentalSettings_BIsAppInBlockList";
SteamAPI_ISteamParentalSettings_BIsFeatureBlocked :: (self: *ISteamParentalSettings, eFeature: EParentalFeature) -> bool #foreign steam "SteamAPI_ISteamParentalSettings_BIsFeatureBlocked";
SteamAPI_ISteamParentalSettings_BIsFeatureInBlockList :: (self: *ISteamParentalSettings, eFeature: EParentalFeature) -> bool #foreign steam "SteamAPI_ISteamParentalSettings_BIsFeatureInBlockList";

// ISteamRemotePlay
SteamAPI_SteamRemotePlay_v001 :: () -> *ISteamRemotePlay #foreign steam "SteamAPI_SteamRemotePlay_v001";
SteamAPI_ISteamRemotePlay_GetSessionCount :: (self: *ISteamRemotePlay) -> uint32 #foreign steam "SteamAPI_ISteamRemotePlay_GetSessionCount";
SteamAPI_ISteamRemotePlay_GetSessionID :: (self: *ISteamRemotePlay, iSessionIndex: s32) -> RemotePlaySessionID_t #foreign steam "SteamAPI_ISteamRemotePlay_GetSessionID";
SteamAPI_ISteamRemotePlay_GetSessionSteamID :: (self: *ISteamRemotePlay, unSessionID: RemotePlaySessionID_t) -> uint64_steamid #foreign steam "SteamAPI_ISteamRemotePlay_GetSessionSteamID";
SteamAPI_ISteamRemotePlay_GetSessionClientName :: (self: *ISteamRemotePlay, unSessionID: RemotePlaySessionID_t) -> *char #foreign steam "SteamAPI_ISteamRemotePlay_GetSessionClientName";
SteamAPI_ISteamRemotePlay_GetSessionClientFormFactor :: (self: *ISteamRemotePlay, unSessionID: RemotePlaySessionID_t) -> ESteamDeviceFormFactor #foreign steam "SteamAPI_ISteamRemotePlay_GetSessionClientFormFactor";
SteamAPI_ISteamRemotePlay_BGetSessionClientResolution :: (self: *ISteamRemotePlay, unSessionID: RemotePlaySessionID_t, pnResolutionX: *s32, pnResolutionY: *s32) -> bool #foreign steam "SteamAPI_ISteamRemotePlay_BGetSessionClientResolution";
SteamAPI_ISteamRemotePlay_BSendRemotePlayTogetherInvite :: (self: *ISteamRemotePlay, steamIDFriend: uint64_steamid) -> bool #foreign steam "SteamAPI_ISteamRemotePlay_BSendRemotePlayTogetherInvite";

// ISteamNetworkingMessages
SteamAPI_SteamNetworkingMessages_v002 :: () -> *ISteamNetworkingMessages #foreign steam "SteamAPI_SteamNetworkingMessages_SteamAPI_v002";
SteamAPI_SteamGameServerNetworkingMessages_v002 :: () -> *ISteamNetworkingMessages #foreign steam "SteamAPI_SteamGameServerNetworkingMessages_SteamAPI_v002";
SteamAPI_ISteamNetworkingMessages_SendMessageToUser :: (self: *ISteamNetworkingMessages, identityRemote: *SteamNetworkingIdentity, pubData: *void, cubData: uint32, nSendFlags: s32, nRemoteChannel: s32) -> EResult #foreign steam "SteamAPI_ISteamNetworkingMessages_SendMessageToUser";
SteamAPI_ISteamNetworkingMessages_ReceiveMessagesOnChannel :: (self: *ISteamNetworkingMessages, nLocalChannel: s32, ppOutMessages: **SteamNetworkingMessage_t, nMaxMessages: s32) -> s32 #foreign steam "SteamAPI_ISteamNetworkingMessages_ReceiveMessagesOnChannel";
SteamAPI_ISteamNetworkingMessages_AcceptSessionWithUser :: (self: *ISteamNetworkingMessages, identityRemote: *SteamNetworkingIdentity) -> bool #foreign steam "SteamAPI_ISteamNetworkingMessages_AcceptSessionWithUser";
SteamAPI_ISteamNetworkingMessages_CloseSessionWithUser :: (self: *ISteamNetworkingMessages, identityRemote: *SteamNetworkingIdentity) -> bool #foreign steam "SteamAPI_ISteamNetworkingMessages_CloseSessionWithUser";
SteamAPI_ISteamNetworkingMessages_CloseChannelWithUser :: (self: *ISteamNetworkingMessages, identityRemote: *SteamNetworkingIdentity, nLocalChannel: s32) -> bool #foreign steam "SteamAPI_ISteamNetworkingMessages_CloseChannelWithUser";
SteamAPI_ISteamNetworkingMessages_GetSessionConnectionInfo :: (self: *ISteamNetworkingMessages, identityRemote: *SteamNetworkingIdentity, pConnectionInfo: *SteamNetConnectionInfo_t, pQuickStatus: *SteamNetworkingQuickConnectionStatus) -> ESteamNetworkingConnectionState #foreign steam "SteamAPI_ISteamNetworkingMessages_GetSessionConnectionInfo";

// ISteamNetworkingSockets
SteamAPI_SteamNetworkingSockets_v009 :: () -> *ISteamNetworkingSockets #foreign steam "SteamAPI_SteamNetworkingSockets_SteamAPI_v009";
SteamAPI_SteamGameServerNetworkingSockets_v009 :: () -> *ISteamNetworkingSockets #foreign steam "SteamAPI_SteamGameServerNetworkingSockets_SteamAPI_v009";
SteamAPI_ISteamNetworkingSockets_CreateListenSocketIP :: (self: *ISteamNetworkingSockets, localAddress: *SteamNetworkingIPAddr, nOptions: s32, pOptions: *SteamNetworkingConfigValue_t) -> HSteamListenSocket #foreign steam "SteamAPI_ISteamNetworkingSockets_CreateListenSocketIP";
SteamAPI_ISteamNetworkingSockets_ConnectByIPAddress :: (self: *ISteamNetworkingSockets, address: *SteamNetworkingIPAddr, nOptions: s32, pOptions: *SteamNetworkingConfigValue_t) -> HSteamNetConnection #foreign steam "SteamAPI_ISteamNetworkingSockets_ConnectByIPAddress";
SteamAPI_ISteamNetworkingSockets_CreateListenSocketP2P :: (self: *ISteamNetworkingSockets, nLocalVirtualPort: s32, nOptions: s32, pOptions: *SteamNetworkingConfigValue_t) -> HSteamListenSocket #foreign steam "SteamAPI_ISteamNetworkingSockets_CreateListenSocketP2P";
SteamAPI_ISteamNetworkingSockets_ConnectP2P :: (self: *ISteamNetworkingSockets, identityRemote: *SteamNetworkingIdentity, nRemoteVirtualPort: s32, nOptions: s32, pOptions: *SteamNetworkingConfigValue_t) -> HSteamNetConnection #foreign steam "SteamAPI_ISteamNetworkingSockets_ConnectP2P";
SteamAPI_ISteamNetworkingSockets_AcceptConnection :: (self: *ISteamNetworkingSockets, hConn: HSteamNetConnection) -> EResult #foreign steam "SteamAPI_ISteamNetworkingSockets_AcceptConnection";
SteamAPI_ISteamNetworkingSockets_CloseConnection :: (self: *ISteamNetworkingSockets, hPeer: HSteamNetConnection, nReason: s32, pszDebug: *char, bEnableLinger: bool) -> bool #foreign steam "SteamAPI_ISteamNetworkingSockets_CloseConnection";
SteamAPI_ISteamNetworkingSockets_CloseListenSocket :: (self: *ISteamNetworkingSockets, hSocket: HSteamListenSocket) -> bool #foreign steam "SteamAPI_ISteamNetworkingSockets_CloseListenSocket";
SteamAPI_ISteamNetworkingSockets_SetConnectionUserData :: (self: *ISteamNetworkingSockets, hPeer: HSteamNetConnection, nUserData: int64) -> bool #foreign steam "SteamAPI_ISteamNetworkingSockets_SetConnectionUserData";
SteamAPI_ISteamNetworkingSockets_GetConnectionUserData :: (self: *ISteamNetworkingSockets, hPeer: HSteamNetConnection) -> int64 #foreign steam "SteamAPI_ISteamNetworkingSockets_GetConnectionUserData";
SteamAPI_ISteamNetworkingSockets_SetConnectionName :: (self: *ISteamNetworkingSockets, hPeer: HSteamNetConnection, pszName: *char) #foreign steam "SteamAPI_ISteamNetworkingSockets_SetConnectionName";
SteamAPI_ISteamNetworkingSockets_GetConnectionName :: (self: *ISteamNetworkingSockets, hPeer: HSteamNetConnection, pszName: *char, nMaxLen: s32) -> bool #foreign steam "SteamAPI_ISteamNetworkingSockets_GetConnectionName";
SteamAPI_ISteamNetworkingSockets_SendMessageToConnection :: (self: *ISteamNetworkingSockets, hConn: HSteamNetConnection, pData: *void, cbData: uint32, nSendFlags: s32, pOutMessageNumber: *int64) -> EResult #foreign steam "SteamAPI_ISteamNetworkingSockets_SendMessageToConnection";
SteamAPI_ISteamNetworkingSockets_SendMessages :: (self: *ISteamNetworkingSockets, nMessages: s32, pMessages: **SteamNetworkingMessage_t, pOutMessageNumberOrResult: *int64) #foreign steam "SteamAPI_ISteamNetworkingSockets_SendMessages";
SteamAPI_ISteamNetworkingSockets_FlushMessagesOnConnection :: (self: *ISteamNetworkingSockets, hConn: HSteamNetConnection) -> EResult #foreign steam "SteamAPI_ISteamNetworkingSockets_FlushMessagesOnConnection";
SteamAPI_ISteamNetworkingSockets_ReceiveMessagesOnConnection :: (self: *ISteamNetworkingSockets, hConn: HSteamNetConnection, ppOutMessages: **SteamNetworkingMessage_t, nMaxMessages: s32) -> s32 #foreign steam "SteamAPI_ISteamNetworkingSockets_ReceiveMessagesOnConnection";
SteamAPI_ISteamNetworkingSockets_GetConnectionInfo :: (self: *ISteamNetworkingSockets, hConn: HSteamNetConnection, pInfo: *SteamNetConnectionInfo_t) -> bool #foreign steam "SteamAPI_ISteamNetworkingSockets_GetConnectionInfo";
SteamAPI_ISteamNetworkingSockets_GetQuickConnectionStatus :: (self: *ISteamNetworkingSockets, hConn: HSteamNetConnection, pStats: *SteamNetworkingQuickConnectionStatus) -> bool #foreign steam "SteamAPI_ISteamNetworkingSockets_GetQuickConnectionStatus";
SteamAPI_ISteamNetworkingSockets_GetDetailedConnectionStatus :: (self: *ISteamNetworkingSockets, hConn: HSteamNetConnection, pszBuf: *char, cbBuf: s32) -> s32 #foreign steam "SteamAPI_ISteamNetworkingSockets_GetDetailedConnectionStatus";
SteamAPI_ISteamNetworkingSockets_GetListenSocketAddress :: (self: *ISteamNetworkingSockets, hSocket: HSteamListenSocket, address: *SteamNetworkingIPAddr) -> bool #foreign steam "SteamAPI_ISteamNetworkingSockets_GetListenSocketAddress";
SteamAPI_ISteamNetworkingSockets_CreateSocketPair :: (self: *ISteamNetworkingSockets, pOutConnection1: *HSteamNetConnection, pOutConnection2: *HSteamNetConnection, bUseNetworkLoopback: bool, pIdentity1: *SteamNetworkingIdentity, pIdentity2: *SteamNetworkingIdentity) -> bool #foreign steam "SteamAPI_ISteamNetworkingSockets_CreateSocketPair";
SteamAPI_ISteamNetworkingSockets_GetIdentity :: (self: *ISteamNetworkingSockets, pIdentity: *SteamNetworkingIdentity) -> bool #foreign steam "SteamAPI_ISteamNetworkingSockets_GetIdentity";
SteamAPI_ISteamNetworkingSockets_InitAuthentication :: (self: *ISteamNetworkingSockets) -> ESteamNetworkingAvailability #foreign steam "SteamAPI_ISteamNetworkingSockets_InitAuthentication";
SteamAPI_ISteamNetworkingSockets_GetAuthenticationStatus :: (self: *ISteamNetworkingSockets, pDetails: *SteamNetAuthenticationStatus_t) -> ESteamNetworkingAvailability #foreign steam "SteamAPI_ISteamNetworkingSockets_GetAuthenticationStatus";
SteamAPI_ISteamNetworkingSockets_CreatePollGroup :: (self: *ISteamNetworkingSockets) -> HSteamNetPollGroup #foreign steam "SteamAPI_ISteamNetworkingSockets_CreatePollGroup";
SteamAPI_ISteamNetworkingSockets_DestroyPollGroup :: (self: *ISteamNetworkingSockets, hPollGroup: HSteamNetPollGroup) -> bool #foreign steam "SteamAPI_ISteamNetworkingSockets_DestroyPollGroup";
SteamAPI_ISteamNetworkingSockets_SetConnectionPollGroup :: (self: *ISteamNetworkingSockets, hConn: HSteamNetConnection, hPollGroup: HSteamNetPollGroup) -> bool #foreign steam "SteamAPI_ISteamNetworkingSockets_SetConnectionPollGroup";
SteamAPI_ISteamNetworkingSockets_ReceiveMessagesOnPollGroup :: (self: *ISteamNetworkingSockets, hPollGroup: HSteamNetPollGroup, ppOutMessages: **SteamNetworkingMessage_t, nMaxMessages: s32) -> s32 #foreign steam "SteamAPI_ISteamNetworkingSockets_ReceiveMessagesOnPollGroup";
SteamAPI_ISteamNetworkingSockets_ReceivedRelayAuthTicket :: (self: *ISteamNetworkingSockets, pvTicket: *void, cbTicket: s32, pOutParsedTicket: *SteamDatagramRelayAuthTicket) -> bool #foreign steam "SteamAPI_ISteamNetworkingSockets_ReceivedRelayAuthTicket";
SteamAPI_ISteamNetworkingSockets_FindRelayAuthTicketForServer :: (self: *ISteamNetworkingSockets, identityGameServer: *SteamNetworkingIdentity, nRemoteVirtualPort: s32, pOutParsedTicket: *SteamDatagramRelayAuthTicket) -> s32 #foreign steam "SteamAPI_ISteamNetworkingSockets_FindRelayAuthTicketForServer";
SteamAPI_ISteamNetworkingSockets_ConnectToHostedDedicatedServer :: (self: *ISteamNetworkingSockets, identityTarget: *SteamNetworkingIdentity, nRemoteVirtualPort: s32, nOptions: s32, pOptions: *SteamNetworkingConfigValue_t) -> HSteamNetConnection #foreign steam "SteamAPI_ISteamNetworkingSockets_ConnectToHostedDedicatedServer";
SteamAPI_ISteamNetworkingSockets_GetHostedDedicatedServerPort :: (self: *ISteamNetworkingSockets) -> uint16 #foreign steam "SteamAPI_ISteamNetworkingSockets_GetHostedDedicatedServerPort";
SteamAPI_ISteamNetworkingSockets_GetHostedDedicatedServerPOPID :: (self: *ISteamNetworkingSockets) -> SteamNetworkingPOPID #foreign steam "SteamAPI_ISteamNetworkingSockets_GetHostedDedicatedServerPOPID";
SteamAPI_ISteamNetworkingSockets_GetHostedDedicatedServerAddress :: (self: *ISteamNetworkingSockets, pRouting: *SteamDatagramHostedAddress) -> EResult #foreign steam "SteamAPI_ISteamNetworkingSockets_GetHostedDedicatedServerAddress";
SteamAPI_ISteamNetworkingSockets_CreateHostedDedicatedServerListenSocket :: (self: *ISteamNetworkingSockets, nLocalVirtualPort: s32, nOptions: s32, pOptions: *SteamNetworkingConfigValue_t) -> HSteamListenSocket #foreign steam "SteamAPI_ISteamNetworkingSockets_CreateHostedDedicatedServerListenSocket";
SteamAPI_ISteamNetworkingSockets_GetGameCoordinatorServerLogin :: (self: *ISteamNetworkingSockets, pLoginInfo: *SteamDatagramGameCoordinatorServerLogin, pcbSignedBlob: *s32, pBlob: *void) -> EResult #foreign steam "SteamAPI_ISteamNetworkingSockets_GetGameCoordinatorServerLogin";
SteamAPI_ISteamNetworkingSockets_ConnectP2PCustomSignaling :: (self: *ISteamNetworkingSockets, pSignaling: *ISteamNetworkingConnectionSignaling, pPeerIdentity: *SteamNetworkingIdentity, nRemoteVirtualPort: s32, nOptions: s32, pOptions: *SteamNetworkingConfigValue_t) -> HSteamNetConnection #foreign steam "SteamAPI_ISteamNetworkingSockets_ConnectP2PCustomSignaling";
SteamAPI_ISteamNetworkingSockets_ReceivedP2PCustomSignal :: (self: *ISteamNetworkingSockets, pMsg: *void, cbMsg: s32, pContext: *ISteamNetworkingSignalingRecvContext) -> bool #foreign steam "SteamAPI_ISteamNetworkingSockets_ReceivedP2PCustomSignal";
SteamAPI_ISteamNetworkingSockets_GetCertificateRequest :: (self: *ISteamNetworkingSockets, pcbBlob: *s32, pBlob: *void, errMsg: *SteamNetworkingErrMsg) -> bool #foreign steam "SteamAPI_ISteamNetworkingSockets_GetCertificateRequest";
SteamAPI_ISteamNetworkingSockets_SetCertificate :: (self: *ISteamNetworkingSockets, pCertificate: *void, cbCertificate: s32, errMsg: *SteamNetworkingErrMsg) -> bool #foreign steam "SteamAPI_ISteamNetworkingSockets_SetCertificate";
SteamAPI_ISteamNetworkingSockets_RunCallbacks :: (self: *ISteamNetworkingSockets) #foreign steam "SteamAPI_ISteamNetworkingSockets_RunCallbacks";

// ISteamNetworkingUtils
SteamAPI_SteamNetworkingUtils_v003 :: () -> *ISteamNetworkingUtils #foreign steam "SteamAPI_SteamNetworkingUtils_SteamAPI_v003";
SteamAPI_ISteamNetworkingUtils_AllocateMessage :: (self: *ISteamNetworkingUtils, cbAllocateBuffer: s32) -> *SteamNetworkingMessage_t #foreign steam "SteamAPI_ISteamNetworkingUtils_AllocateMessage";
SteamAPI_ISteamNetworkingUtils_InitRelayNetworkAccess :: (self: *ISteamNetworkingUtils) #foreign steam "SteamAPI_ISteamNetworkingUtils_InitRelayNetworkAccess";
SteamAPI_ISteamNetworkingUtils_GetRelayNetworkStatus :: (self: *ISteamNetworkingUtils, pDetails: *SteamRelayNetworkStatus_t) -> ESteamNetworkingAvailability #foreign steam "SteamAPI_ISteamNetworkingUtils_GetRelayNetworkStatus";
SteamAPI_ISteamNetworkingUtils_GetLocalPingLocation :: (self: *ISteamNetworkingUtils, result: *SteamNetworkPingLocation_t) -> float #foreign steam "SteamAPI_ISteamNetworkingUtils_GetLocalPingLocation";
SteamAPI_ISteamNetworkingUtils_EstimatePingTimeBetweenTwoLocations :: (self: *ISteamNetworkingUtils, location1: *SteamNetworkPingLocation_t, location2: *SteamNetworkPingLocation_t) -> s32 #foreign steam "SteamAPI_ISteamNetworkingUtils_EstimatePingTimeBetweenTwoLocations";
SteamAPI_ISteamNetworkingUtils_EstimatePingTimeFromLocalHost :: (self: *ISteamNetworkingUtils, remoteLocation: *SteamNetworkPingLocation_t) -> s32 #foreign steam "SteamAPI_ISteamNetworkingUtils_EstimatePingTimeFromLocalHost";
SteamAPI_ISteamNetworkingUtils_ConvertPingLocationToString :: (self: *ISteamNetworkingUtils, location: *SteamNetworkPingLocation_t, pszBuf: *char, cchBufSize: s32) #foreign steam "SteamAPI_ISteamNetworkingUtils_ConvertPingLocationToString";
SteamAPI_ISteamNetworkingUtils_ParsePingLocationString :: (self: *ISteamNetworkingUtils, pszString: *char, result: *SteamNetworkPingLocation_t) -> bool #foreign steam "SteamAPI_ISteamNetworkingUtils_ParsePingLocationString";
SteamAPI_ISteamNetworkingUtils_CheckPingDataUpToDate :: (self: *ISteamNetworkingUtils, flMaxAgeSeconds: float) -> bool #foreign steam "SteamAPI_ISteamNetworkingUtils_CheckPingDataUpToDate";
SteamAPI_ISteamNetworkingUtils_GetPingToDataCenter :: (self: *ISteamNetworkingUtils, popID: SteamNetworkingPOPID, pViaRelayPoP: *SteamNetworkingPOPID) -> s32 #foreign steam "SteamAPI_ISteamNetworkingUtils_GetPingToDataCenter";
SteamAPI_ISteamNetworkingUtils_GetDirectPingToPOP :: (self: *ISteamNetworkingUtils, popID: SteamNetworkingPOPID) -> s32 #foreign steam "SteamAPI_ISteamNetworkingUtils_GetDirectPingToPOP";
SteamAPI_ISteamNetworkingUtils_GetPOPCount :: (self: *ISteamNetworkingUtils) -> s32 #foreign steam "SteamAPI_ISteamNetworkingUtils_GetPOPCount";
SteamAPI_ISteamNetworkingUtils_GetPOPList :: (self: *ISteamNetworkingUtils, list: *SteamNetworkingPOPID, nListSz: s32) -> s32 #foreign steam "SteamAPI_ISteamNetworkingUtils_GetPOPList";
SteamAPI_ISteamNetworkingUtils_GetLocalTimestamp :: (self: *ISteamNetworkingUtils) -> SteamNetworkingMicroseconds #foreign steam "SteamAPI_ISteamNetworkingUtils_GetLocalTimestamp";
SteamAPI_ISteamNetworkingUtils_SetDebugOutputFunction :: (self: *ISteamNetworkingUtils, eDetailLevel: ESteamNetworkingSocketsDebugOutputType, pfnFunc: FSteamNetworkingSocketsDebugOutput) #foreign steam "SteamAPI_ISteamNetworkingUtils_SetDebugOutputFunction";
SteamAPI_ISteamNetworkingUtils_SetGlobalConfigValueInt32 :: (self: *ISteamNetworkingUtils, eValue: ESteamNetworkingConfigValue, val: int32) -> bool #foreign steam "SteamAPI_ISteamNetworkingUtils_SetGlobalConfigValueInt32";
SteamAPI_ISteamNetworkingUtils_SetGlobalConfigValueFloat :: (self: *ISteamNetworkingUtils, eValue: ESteamNetworkingConfigValue, val: float) -> bool #foreign steam "SteamAPI_ISteamNetworkingUtils_SetGlobalConfigValueFloat";
SteamAPI_ISteamNetworkingUtils_SetGlobalConfigValueString :: (self: *ISteamNetworkingUtils, eValue: ESteamNetworkingConfigValue, val: *char) -> bool #foreign steam "SteamAPI_ISteamNetworkingUtils_SetGlobalConfigValueString";
SteamAPI_ISteamNetworkingUtils_SetGlobalConfigValuePtr :: (self: *ISteamNetworkingUtils, eValue: ESteamNetworkingConfigValue, val: *void) -> bool #foreign steam "SteamAPI_ISteamNetworkingUtils_SetGlobalConfigValuePtr";
SteamAPI_ISteamNetworkingUtils_SetConnectionConfigValueInt32 :: (self: *ISteamNetworkingUtils, hConn: HSteamNetConnection, eValue: ESteamNetworkingConfigValue, val: int32) -> bool #foreign steam "SteamAPI_ISteamNetworkingUtils_SetConnectionConfigValueInt32";
SteamAPI_ISteamNetworkingUtils_SetConnectionConfigValueFloat :: (self: *ISteamNetworkingUtils, hConn: HSteamNetConnection, eValue: ESteamNetworkingConfigValue, val: float) -> bool #foreign steam "SteamAPI_ISteamNetworkingUtils_SetConnectionConfigValueFloat";
SteamAPI_ISteamNetworkingUtils_SetConnectionConfigValueString :: (self: *ISteamNetworkingUtils, hConn: HSteamNetConnection, eValue: ESteamNetworkingConfigValue, val: *char) -> bool #foreign steam "SteamAPI_ISteamNetworkingUtils_SetConnectionConfigValueString";
SteamAPI_ISteamNetworkingUtils_SetGlobalCallback_SteamNetConnectionStatusChanged :: (self: *ISteamNetworkingUtils, fnCallback: FnSteamNetConnectionStatusChanged) -> bool #foreign steam "SteamAPI_ISteamNetworkingUtils_SetGlobalCallback_SteamNetConnectionStatusChanged";
SteamAPI_ISteamNetworkingUtils_SetGlobalCallback_SteamNetAuthenticationStatusChanged :: (self: *ISteamNetworkingUtils, fnCallback: FnSteamNetAuthenticationStatusChanged) -> bool #foreign steam "SteamAPI_ISteamNetworkingUtils_SetGlobalCallback_SteamNetAuthenticationStatusChanged";
SteamAPI_ISteamNetworkingUtils_SetGlobalCallback_SteamRelayNetworkStatusChanged :: (self: *ISteamNetworkingUtils, fnCallback: FnSteamRelayNetworkStatusChanged) -> bool #foreign steam "SteamAPI_ISteamNetworkingUtils_SetGlobalCallback_SteamRelayNetworkStatusChanged";
SteamAPI_ISteamNetworkingUtils_SetGlobalCallback_MessagesSessionRequest :: (self: *ISteamNetworkingUtils, fnCallback: FnSteamNetworkingMessagesSessionRequest) -> bool #foreign steam "SteamAPI_ISteamNetworkingUtils_SetGlobalCallback_MessagesSessionRequest";
SteamAPI_ISteamNetworkingUtils_SetGlobalCallback_MessagesSessionFailed :: (self: *ISteamNetworkingUtils, fnCallback: FnSteamNetworkingMessagesSessionFailed) -> bool #foreign steam "SteamAPI_ISteamNetworkingUtils_SetGlobalCallback_MessagesSessionFailed";
SteamAPI_ISteamNetworkingUtils_SetConfigValue :: (self: *ISteamNetworkingUtils, eValue: ESteamNetworkingConfigValue, eScopeType: ESteamNetworkingConfigScope, scopeObj: intptr_t, eDataType: ESteamNetworkingConfigDataType, pArg: *void) -> bool #foreign steam "SteamAPI_ISteamNetworkingUtils_SetConfigValue";
SteamAPI_ISteamNetworkingUtils_SetConfigValueStruct :: (self: *ISteamNetworkingUtils, opt: *SteamNetworkingConfigValue_t, eScopeType: ESteamNetworkingConfigScope, scopeObj: intptr_t) -> bool #foreign steam "SteamAPI_ISteamNetworkingUtils_SetConfigValueStruct";
SteamAPI_ISteamNetworkingUtils_GetConfigValue :: (self: *ISteamNetworkingUtils, eValue: ESteamNetworkingConfigValue, eScopeType: ESteamNetworkingConfigScope, scopeObj: intptr_t, pOutDataType: *ESteamNetworkingConfigDataType, pResult: *void, cbResult: *size_t) -> ESteamNetworkingGetConfigValueResult #foreign steam "SteamAPI_ISteamNetworkingUtils_GetConfigValue";
SteamAPI_ISteamNetworkingUtils_GetConfigValueInfo :: (self: *ISteamNetworkingUtils, eValue: ESteamNetworkingConfigValue, pOutName: **char, pOutDataType: *ESteamNetworkingConfigDataType, pOutScope: *ESteamNetworkingConfigScope, pOutNextValue: *ESteamNetworkingConfigValue) -> bool #foreign steam "SteamAPI_ISteamNetworkingUtils_GetConfigValueInfo";
SteamAPI_ISteamNetworkingUtils_GetFirstConfigValue :: (self: *ISteamNetworkingUtils) -> ESteamNetworkingConfigValue #foreign steam "SteamAPI_ISteamNetworkingUtils_GetFirstConfigValue";
SteamAPI_ISteamNetworkingUtils_SteamNetworkingIPAddr_ToString :: (self: *ISteamNetworkingUtils, addr: *SteamNetworkingIPAddr, buf: *char, cbBuf: uint32, bWithPort: bool) #foreign steam "SteamAPI_ISteamNetworkingUtils_SteamNetworkingIPAddr_ToString";
SteamAPI_ISteamNetworkingUtils_SteamNetworkingIPAddr_ParseString :: (self: *ISteamNetworkingUtils, pAddr: *SteamNetworkingIPAddr, pszStr: *char) -> bool #foreign steam "SteamAPI_ISteamNetworkingUtils_SteamNetworkingIPAddr_ParseString";
SteamAPI_ISteamNetworkingUtils_SteamNetworkingIdentity_ToString :: (self: *ISteamNetworkingUtils, identity: *SteamNetworkingIdentity, buf: *char, cbBuf: uint32) #foreign steam "SteamAPI_ISteamNetworkingUtils_SteamNetworkingIdentity_ToString";
SteamAPI_ISteamNetworkingUtils_SteamNetworkingIdentity_ParseString :: (self: *ISteamNetworkingUtils, pIdentity: *SteamNetworkingIdentity, pszStr: *char) -> bool #foreign steam "SteamAPI_ISteamNetworkingUtils_SteamNetworkingIdentity_ParseString";

// ISteamGameServer
SteamAPI_SteamGameServer_v013 :: () -> *ISteamGameServer #foreign steam "SteamAPI_SteamGameServer_v013";
SteamAPI_ISteamGameServer_SetProduct :: (self: *ISteamGameServer, pszProduct: *char) #foreign steam "SteamAPI_ISteamGameServer_SetProduct";
SteamAPI_ISteamGameServer_SetGameDescription :: (self: *ISteamGameServer, pszGameDescription: *char) #foreign steam "SteamAPI_ISteamGameServer_SetGameDescription";
SteamAPI_ISteamGameServer_SetModDir :: (self: *ISteamGameServer, pszModDir: *char) #foreign steam "SteamAPI_ISteamGameServer_SetModDir";
SteamAPI_ISteamGameServer_SetDedicatedServer :: (self: *ISteamGameServer, bDedicated: bool) #foreign steam "SteamAPI_ISteamGameServer_SetDedicatedServer";
SteamAPI_ISteamGameServer_LogOn :: (self: *ISteamGameServer, pszToken: *char) #foreign steam "SteamAPI_ISteamGameServer_LogOn";
SteamAPI_ISteamGameServer_LogOnAnonymous :: (self: *ISteamGameServer) #foreign steam "SteamAPI_ISteamGameServer_LogOnAnonymous";
SteamAPI_ISteamGameServer_LogOff :: (self: *ISteamGameServer) #foreign steam "SteamAPI_ISteamGameServer_LogOff";
SteamAPI_ISteamGameServer_BLoggedOn :: (self: *ISteamGameServer) -> bool #foreign steam "SteamAPI_ISteamGameServer_BLoggedOn";
SteamAPI_ISteamGameServer_BSecure :: (self: *ISteamGameServer) -> bool #foreign steam "SteamAPI_ISteamGameServer_BSecure";
SteamAPI_ISteamGameServer_GetSteamID :: (self: *ISteamGameServer) -> uint64_steamid #foreign steam "SteamAPI_ISteamGameServer_GetSteamID";
SteamAPI_ISteamGameServer_WasRestartRequested :: (self: *ISteamGameServer) -> bool #foreign steam "SteamAPI_ISteamGameServer_WasRestartRequested";
SteamAPI_ISteamGameServer_SetMaxPlayerCount :: (self: *ISteamGameServer, cPlayersMax: s32) #foreign steam "SteamAPI_ISteamGameServer_SetMaxPlayerCount";
SteamAPI_ISteamGameServer_SetBotPlayerCount :: (self: *ISteamGameServer, cBotplayers: s32) #foreign steam "SteamAPI_ISteamGameServer_SetBotPlayerCount";
SteamAPI_ISteamGameServer_SetServerName :: (self: *ISteamGameServer, pszServerName: *char) #foreign steam "SteamAPI_ISteamGameServer_SetServerName";
SteamAPI_ISteamGameServer_SetMapName :: (self: *ISteamGameServer, pszMapName: *char) #foreign steam "SteamAPI_ISteamGameServer_SetMapName";
SteamAPI_ISteamGameServer_SetPasswordProtected :: (self: *ISteamGameServer, bPasswordProtected: bool) #foreign steam "SteamAPI_ISteamGameServer_SetPasswordProtected";
SteamAPI_ISteamGameServer_SetSpectatorPort :: (self: *ISteamGameServer, unSpectatorPort: uint16) #foreign steam "SteamAPI_ISteamGameServer_SetSpectatorPort";
SteamAPI_ISteamGameServer_SetSpectatorServerName :: (self: *ISteamGameServer, pszSpectatorServerName: *char) #foreign steam "SteamAPI_ISteamGameServer_SetSpectatorServerName";
SteamAPI_ISteamGameServer_ClearAllKeyValues :: (self: *ISteamGameServer) #foreign steam "SteamAPI_ISteamGameServer_ClearAllKeyValues";
SteamAPI_ISteamGameServer_SetKeyValue :: (self: *ISteamGameServer, pKey: *char, pValue: *char) #foreign steam "SteamAPI_ISteamGameServer_SetKeyValue";
SteamAPI_ISteamGameServer_SetGameTags :: (self: *ISteamGameServer, pchGameTags: *char) #foreign steam "SteamAPI_ISteamGameServer_SetGameTags";
SteamAPI_ISteamGameServer_SetGameData :: (self: *ISteamGameServer, pchGameData: *char) #foreign steam "SteamAPI_ISteamGameServer_SetGameData";
SteamAPI_ISteamGameServer_SetRegion :: (self: *ISteamGameServer, pszRegion: *char) #foreign steam "SteamAPI_ISteamGameServer_SetRegion";
SteamAPI_ISteamGameServer_SendUserConnectAndAuthenticate :: (self: *ISteamGameServer, unIPClient: uint32, pvAuthBlob: *void, cubAuthBlobSize: uint32, pSteamIDUser: *CSteamID) -> bool #foreign steam "SteamAPI_ISteamGameServer_SendUserConnectAndAuthenticate";
SteamAPI_ISteamGameServer_CreateUnauthenticatedUserConnection :: (self: *ISteamGameServer) -> uint64_steamid #foreign steam "SteamAPI_ISteamGameServer_CreateUnauthenticatedUserConnection";
SteamAPI_ISteamGameServer_SendUserDisconnect :: (self: *ISteamGameServer, steamIDUser: uint64_steamid) #foreign steam "SteamAPI_ISteamGameServer_SendUserDisconnect";
SteamAPI_ISteamGameServer_BUpdateUserData :: (self: *ISteamGameServer, steamIDUser: uint64_steamid, pchPlayerName: *char, uScore: uint32) -> bool #foreign steam "SteamAPI_ISteamGameServer_BUpdateUserData";
SteamAPI_ISteamGameServer_GetAuthSessionTicket :: (self: *ISteamGameServer, pTicket: *void, cbMaxTicket: s32, pcbTicket: *uint32) -> HAuthTicket #foreign steam "SteamAPI_ISteamGameServer_GetAuthSessionTicket";
SteamAPI_ISteamGameServer_BeginAuthSession :: (self: *ISteamGameServer, pAuthTicket: *void, cbAuthTicket: s32, steamID: uint64_steamid) -> EBeginAuthSessionResult #foreign steam "SteamAPI_ISteamGameServer_BeginAuthSession";
SteamAPI_ISteamGameServer_EndAuthSession :: (self: *ISteamGameServer, steamID: uint64_steamid) #foreign steam "SteamAPI_ISteamGameServer_EndAuthSession";
SteamAPI_ISteamGameServer_CancelAuthTicket :: (self: *ISteamGameServer, hAuthTicket: HAuthTicket) #foreign steam "SteamAPI_ISteamGameServer_CancelAuthTicket";
SteamAPI_ISteamGameServer_UserHasLicenseForApp :: (self: *ISteamGameServer, steamID: uint64_steamid, appID: AppId_t) -> EUserHasLicenseForAppResult #foreign steam "SteamAPI_ISteamGameServer_UserHasLicenseForApp";
SteamAPI_ISteamGameServer_RequestUserGroupStatus :: (self: *ISteamGameServer, steamIDUser: uint64_steamid, steamIDGroup: uint64_steamid) -> bool #foreign steam "SteamAPI_ISteamGameServer_RequestUserGroupStatus";
SteamAPI_ISteamGameServer_GetGameplayStats :: (self: *ISteamGameServer) #foreign steam "SteamAPI_ISteamGameServer_GetGameplayStats";
SteamAPI_ISteamGameServer_GetServerReputation :: (self: *ISteamGameServer) -> SteamAPICall_t #must #foreign steam "SteamAPI_ISteamGameServer_GetServerReputation";
SteamAPI_ISteamGameServer_GetPublicIP :: (self: *ISteamGameServer) -> SteamIPAddress_t #foreign steam "SteamAPI_ISteamGameServer_GetPublicIP";
SteamAPI_ISteamGameServer_HandleIncomingPacket :: (self: *ISteamGameServer, pData: *void, cbData: s32, srcIP: uint32, srcPort: uint16) -> bool #foreign steam "SteamAPI_ISteamGameServer_HandleIncomingPacket";
SteamAPI_ISteamGameServer_GetNextOutgoingPacket :: (self: *ISteamGameServer, pOut: *void, cbMaxOut: s32, pNetAdr: *uint32, pPort: *uint16) -> s32 #foreign steam "SteamAPI_ISteamGameServer_GetNextOutgoingPacket";
SteamAPI_ISteamGameServer_EnableHeartbeats :: (self: *ISteamGameServer, bActive: bool) #foreign steam "SteamAPI_ISteamGameServer_EnableHeartbeats";
SteamAPI_ISteamGameServer_SetHeartbeatInterval :: (self: *ISteamGameServer, iHeartbeatInterval: s32) #foreign steam "SteamAPI_ISteamGameServer_SetHeartbeatInterval";
SteamAPI_ISteamGameServer_ForceHeartbeat :: (self: *ISteamGameServer) #foreign steam "SteamAPI_ISteamGameServer_ForceHeartbeat";
SteamAPI_ISteamGameServer_AssociateWithClan :: (self: *ISteamGameServer, steamIDClan: uint64_steamid) -> SteamAPICall_t #must #foreign steam "SteamAPI_ISteamGameServer_AssociateWithClan";
SteamAPI_ISteamGameServer_ComputeNewPlayerCompatibility :: (self: *ISteamGameServer, steamIDNewPlayer: uint64_steamid) -> SteamAPICall_t #must #foreign steam "SteamAPI_ISteamGameServer_ComputeNewPlayerCompatibility";

// ISteamGameServerStats
SteamAPI_SteamGameServerStats_v001 :: () -> *ISteamGameServerStats #foreign steam "SteamAPI_SteamGameServerStats_v001";
SteamAPI_ISteamGameServerStats_RequestUserStats :: (self: *ISteamGameServerStats, steamIDUser: uint64_steamid) -> SteamAPICall_t #must #foreign steam "SteamAPI_ISteamGameServerStats_RequestUserStats";
SteamAPI_ISteamGameServerStats_GetUserStatInt32 :: (self: *ISteamGameServerStats, steamIDUser: uint64_steamid, pchName: *char, pData: *int32) -> bool #foreign steam "SteamAPI_ISteamGameServerStats_GetUserStatInt32";
SteamAPI_ISteamGameServerStats_GetUserStatFloat :: (self: *ISteamGameServerStats, steamIDUser: uint64_steamid, pchName: *char, pData: *float) -> bool #foreign steam "SteamAPI_ISteamGameServerStats_GetUserStatFloat";
SteamAPI_ISteamGameServerStats_GetUserAchievement :: (self: *ISteamGameServerStats, steamIDUser: uint64_steamid, pchName: *char, pbAchieved: *bool) -> bool #foreign steam "SteamAPI_ISteamGameServerStats_GetUserAchievement";
SteamAPI_ISteamGameServerStats_SetUserStatInt32 :: (self: *ISteamGameServerStats, steamIDUser: uint64_steamid, pchName: *char, nData: int32) -> bool #foreign steam "SteamAPI_ISteamGameServerStats_SetUserStatInt32";
SteamAPI_ISteamGameServerStats_SetUserStatFloat :: (self: *ISteamGameServerStats, steamIDUser: uint64_steamid, pchName: *char, fData: float) -> bool #foreign steam "SteamAPI_ISteamGameServerStats_SetUserStatFloat";
SteamAPI_ISteamGameServerStats_UpdateUserAvgRateStat :: (self: *ISteamGameServerStats, steamIDUser: uint64_steamid, pchName: *char, flCountThisSession: float, dSessionLength: double) -> bool #foreign steam "SteamAPI_ISteamGameServerStats_UpdateUserAvgRateStat";
SteamAPI_ISteamGameServerStats_SetUserAchievement :: (self: *ISteamGameServerStats, steamIDUser: uint64_steamid, pchName: *char) -> bool #foreign steam "SteamAPI_ISteamGameServerStats_SetUserAchievement";
SteamAPI_ISteamGameServerStats_ClearUserAchievement :: (self: *ISteamGameServerStats, steamIDUser: uint64_steamid, pchName: *char) -> bool #foreign steam "SteamAPI_ISteamGameServerStats_ClearUserAchievement";
SteamAPI_ISteamGameServerStats_StoreUserStats :: (self: *ISteamGameServerStats, steamIDUser: uint64_steamid) -> SteamAPICall_t #must #foreign steam "SteamAPI_ISteamGameServerStats_StoreUserStats";

// SteamIPAddress_t
SteamAPI_SteamIPAddress_t_IsSet :: (self: *SteamIPAddress_t) -> bool #foreign steam "SteamAPI_SteamIPAddress_t_IsSet";

// MatchMakingKeyValuePair_t
SteamAPI_MatchMakingKeyValuePair_t_Construct :: (self: *MatchMakingKeyValuePair_t) #foreign steam "SteamAPI_MatchMakingKeyValuePair_t_Construct";

// servernetadr_t
SteamAPI_servernetadr_t_Construct :: (self: *servernetadr_t) #foreign steam "SteamAPI_servernetadr_t_Construct";
SteamAPI_servernetadr_t_Init :: (self: *servernetadr_t, ip: u32, usQueryPort: uint16, usConnectionPort: uint16) #foreign steam "SteamAPI_servernetadr_t_Init";
SteamAPI_servernetadr_t_GetQueryPort :: (self: *servernetadr_t) -> uint16 #foreign steam "SteamAPI_servernetadr_t_GetQueryPort";
SteamAPI_servernetadr_t_SetQueryPort :: (self: *servernetadr_t, usPort: uint16) #foreign steam "SteamAPI_servernetadr_t_SetQueryPort";
SteamAPI_servernetadr_t_GetConnectionPort :: (self: *servernetadr_t) -> uint16 #foreign steam "SteamAPI_servernetadr_t_GetConnectionPort";
SteamAPI_servernetadr_t_SetConnectionPort :: (self: *servernetadr_t, usPort: uint16) #foreign steam "SteamAPI_servernetadr_t_SetConnectionPort";
SteamAPI_servernetadr_t_GetIP :: (self: *servernetadr_t) -> uint32 #foreign steam "SteamAPI_servernetadr_t_GetIP";
SteamAPI_servernetadr_t_SetIP :: (self: *servernetadr_t, unIP: uint32) #foreign steam "SteamAPI_servernetadr_t_SetIP";
SteamAPI_servernetadr_t_GetConnectionAddressString :: (self: *servernetadr_t) -> *char #foreign steam "SteamAPI_servernetadr_t_GetConnectionAddressString";
SteamAPI_servernetadr_t_GetQueryAddressString :: (self: *servernetadr_t) -> *char #foreign steam "SteamAPI_servernetadr_t_GetQueryAddressString";
SteamAPI_servernetadr_t_IsLessThan :: (self: *servernetadr_t, netadr: *servernetadr_t) -> bool #foreign steam "SteamAPI_servernetadr_t_IsLessThan";
SteamAPI_servernetadr_t_Assign :: (self: *servernetadr_t, that: *servernetadr_t) #foreign steam "SteamAPI_servernetadr_t_Assign";

// gameserveritem_t
SteamAPI_gameserveritem_t_Construct :: (self: *gameserveritem_t) #foreign steam "SteamAPI_gameserveritem_t_Construct";
SteamAPI_gameserveritem_t_GetName :: (self: *gameserveritem_t) -> *char #foreign steam "SteamAPI_gameserveritem_t_GetName";
SteamAPI_gameserveritem_t_SetName :: (self: *gameserveritem_t, pName: *char) #foreign steam "SteamAPI_gameserveritem_t_SetName";

// SteamNetworkingIPAddr
SteamAPI_SteamNetworkingIPAddr_Clear :: (self: *SteamNetworkingIPAddr) #foreign steam "SteamAPI_SteamNetworkingIPAddr_Clear";
SteamAPI_SteamNetworkingIPAddr_IsIPv6AllZeros :: (self: *SteamNetworkingIPAddr) -> bool #foreign steam "SteamAPI_SteamNetworkingIPAddr_IsIPv6AllZeros";
SteamAPI_SteamNetworkingIPAddr_SetIPv6 :: (self: *SteamNetworkingIPAddr, ipv6: *uint8, nPort: uint16) #foreign steam "SteamAPI_SteamNetworkingIPAddr_SetIPv6";
SteamAPI_SteamNetworkingIPAddr_SetIPv4 :: (self: *SteamNetworkingIPAddr, nIP: uint32, nPort: uint16) #foreign steam "SteamAPI_SteamNetworkingIPAddr_SetIPv4";
SteamAPI_SteamNetworkingIPAddr_IsIPv4 :: (self: *SteamNetworkingIPAddr) -> bool #foreign steam "SteamAPI_SteamNetworkingIPAddr_IsIPv4";
SteamAPI_SteamNetworkingIPAddr_GetIPv4 :: (self: *SteamNetworkingIPAddr) -> uint32 #foreign steam "SteamAPI_SteamNetworkingIPAddr_GetIPv4";
SteamAPI_SteamNetworkingIPAddr_SetIPv6LocalHost :: (self: *SteamNetworkingIPAddr, nPort: uint16) #foreign steam "SteamAPI_SteamNetworkingIPAddr_SetIPv6LocalHost";
SteamAPI_SteamNetworkingIPAddr_IsLocalHost :: (self: *SteamNetworkingIPAddr) -> bool #foreign steam "SteamAPI_SteamNetworkingIPAddr_IsLocalHost";
SteamAPI_SteamNetworkingIPAddr_ToString :: (self: *SteamNetworkingIPAddr, buf: *char, cbBuf: uint32, bWithPort: bool) #foreign steam "SteamAPI_SteamNetworkingIPAddr_ToString";
SteamAPI_SteamNetworkingIPAddr_ParseString :: (self: *SteamNetworkingIPAddr, pszStr: *char) -> bool #foreign steam "SteamAPI_SteamNetworkingIPAddr_ParseString";
SteamAPI_SteamNetworkingIPAddr_IsEqualTo :: (self: *SteamNetworkingIPAddr, x: *SteamNetworkingIPAddr) -> bool #foreign steam "SteamAPI_SteamNetworkingIPAddr_IsEqualTo";

// SteamNetworkingIdentity
SteamAPI_SteamNetworkingIdentity_Clear :: (self: *SteamNetworkingIdentity) #foreign steam "SteamAPI_SteamNetworkingIdentity_Clear";
SteamAPI_SteamNetworkingIdentity_IsInvalid :: (self: *SteamNetworkingIdentity) -> bool #foreign steam "SteamAPI_SteamNetworkingIdentity_IsInvalid";
SteamAPI_SteamNetworkingIdentity_SetSteamID :: (self: *SteamNetworkingIdentity, steamID: uint64_steamid) #foreign steam "SteamAPI_SteamNetworkingIdentity_SetSteamID";
SteamAPI_SteamNetworkingIdentity_GetSteamID :: (self: *SteamNetworkingIdentity) -> uint64_steamid #foreign steam "SteamAPI_SteamNetworkingIdentity_GetSteamID";
SteamAPI_SteamNetworkingIdentity_SetSteamID64 :: (self: *SteamNetworkingIdentity, steamID: uint64) #foreign steam "SteamAPI_SteamNetworkingIdentity_SetSteamID64";
SteamAPI_SteamNetworkingIdentity_GetSteamID64 :: (self: *SteamNetworkingIdentity) -> uint64 #foreign steam "SteamAPI_SteamNetworkingIdentity_GetSteamID64";
SteamAPI_SteamNetworkingIdentity_SetXboxPairwiseID :: (self: *SteamNetworkingIdentity, pszString: *char) -> bool #foreign steam "SteamAPI_SteamNetworkingIdentity_SetXboxPairwiseID";
SteamAPI_SteamNetworkingIdentity_GetXboxPairwiseID :: (self: *SteamNetworkingIdentity) -> *char #foreign steam "SteamAPI_SteamNetworkingIdentity_GetXboxPairwiseID";
SteamAPI_SteamNetworkingIdentity_SetPSNID :: (self: *SteamNetworkingIdentity, id: uint64) #foreign steam "SteamAPI_SteamNetworkingIdentity_SetPSNID";
SteamAPI_SteamNetworkingIdentity_GetPSNID :: (self: *SteamNetworkingIdentity) -> uint64 #foreign steam "SteamAPI_SteamNetworkingIdentity_GetPSNID";
SteamAPI_SteamNetworkingIdentity_SetStadiaID :: (self: *SteamNetworkingIdentity, id: uint64) #foreign steam "SteamAPI_SteamNetworkingIdentity_SetStadiaID";
SteamAPI_SteamNetworkingIdentity_GetStadiaID :: (self: *SteamNetworkingIdentity) -> uint64 #foreign steam "SteamAPI_SteamNetworkingIdentity_GetStadiaID";
SteamAPI_SteamNetworkingIdentity_SetIPAddr :: (self: *SteamNetworkingIdentity, addr: *SteamNetworkingIPAddr) #foreign steam "SteamAPI_SteamNetworkingIdentity_SetIPAddr";
SteamAPI_SteamNetworkingIdentity_GetIPAddr :: (self: *SteamNetworkingIdentity) -> *SteamNetworkingIPAddr #foreign steam "SteamAPI_SteamNetworkingIdentity_GetIPAddr";
SteamAPI_SteamNetworkingIdentity_SetLocalHost :: (self: *SteamNetworkingIdentity) #foreign steam "SteamAPI_SteamNetworkingIdentity_SetLocalHost";
SteamAPI_SteamNetworkingIdentity_IsLocalHost :: (self: *SteamNetworkingIdentity) -> bool #foreign steam "SteamAPI_SteamNetworkingIdentity_IsLocalHost";
SteamAPI_SteamNetworkingIdentity_SetGenericString :: (self: *SteamNetworkingIdentity, pszString: *char) -> bool #foreign steam "SteamAPI_SteamNetworkingIdentity_SetGenericString";
SteamAPI_SteamNetworkingIdentity_GetGenericString :: (self: *SteamNetworkingIdentity) -> *char #foreign steam "SteamAPI_SteamNetworkingIdentity_GetGenericString";
SteamAPI_SteamNetworkingIdentity_SetGenericBytes :: (self: *SteamNetworkingIdentity, data: *void, cbLen: uint32) -> bool #foreign steam "SteamAPI_SteamNetworkingIdentity_SetGenericBytes";
SteamAPI_SteamNetworkingIdentity_GetGenericBytes :: (self: *SteamNetworkingIdentity, cbLen: *s32) -> *uint8 #foreign steam "SteamAPI_SteamNetworkingIdentity_GetGenericBytes";
SteamAPI_SteamNetworkingIdentity_IsEqualTo :: (self: *SteamNetworkingIdentity, x: *SteamNetworkingIdentity) -> bool #foreign steam "SteamAPI_SteamNetworkingIdentity_IsEqualTo";
SteamAPI_SteamNetworkingIdentity_ToString :: (self: *SteamNetworkingIdentity, buf: *char, cbBuf: uint32) #foreign steam "SteamAPI_SteamNetworkingIdentity_ToString";
SteamAPI_SteamNetworkingIdentity_ParseString :: (self: *SteamNetworkingIdentity, pszStr: *char) -> bool #foreign steam "SteamAPI_SteamNetworkingIdentity_ParseString";

// SteamNetworkingMessage_t
SteamAPI_SteamNetworkingMessage_t_Release :: (self: *SteamNetworkingMessage_t) #foreign steam "SteamAPI_SteamNetworkingMessage_t_Release";

// SteamNetworkingConfigValue_t
SteamAPI_SteamNetworkingConfigValue_t_SetInt32 :: (self: *SteamNetworkingConfigValue_t, eVal: ESteamNetworkingConfigValue, data: int32_t) #foreign steam "SteamAPI_SteamNetworkingConfigValue_t_SetInt32";
SteamAPI_SteamNetworkingConfigValue_t_SetInt64 :: (self: *SteamNetworkingConfigValue_t, eVal: ESteamNetworkingConfigValue, data: int64_t) #foreign steam "SteamAPI_SteamNetworkingConfigValue_t_SetInt64";
SteamAPI_SteamNetworkingConfigValue_t_SetFloat :: (self: *SteamNetworkingConfigValue_t, eVal: ESteamNetworkingConfigValue, data: float) #foreign steam "SteamAPI_SteamNetworkingConfigValue_t_SetFloat";
SteamAPI_SteamNetworkingConfigValue_t_SetPtr :: (self: *SteamNetworkingConfigValue_t, eVal: ESteamNetworkingConfigValue, data: *void) #foreign steam "SteamAPI_SteamNetworkingConfigValue_t_SetPtr";
SteamAPI_SteamNetworkingConfigValue_t_SetString :: (self: *SteamNetworkingConfigValue_t, eVal: ESteamNetworkingConfigValue, data: *char) #foreign steam "SteamAPI_SteamNetworkingConfigValue_t_SetString";

// SteamNetworkingPOPIDRender
SteamAPI_SteamNetworkingPOPIDRender_c_str :: (self: *SteamNetworkingPOPIDRender) -> *char #foreign steam "SteamAPI_SteamNetworkingPOPIDRender_c_str";

// SteamNetworkingIdentityRender
SteamAPI_SteamNetworkingIdentityRender_c_str :: (self: *SteamNetworkingIdentityRender) -> *char #foreign steam "SteamAPI_SteamNetworkingIdentityRender_c_str";

// SteamNetworkingIPAddrRender
SteamAPI_SteamNetworkingIPAddrRender_c_str :: (self: *SteamNetworkingIPAddrRender) -> *char #foreign steam "SteamAPI_SteamNetworkingIPAddrRender_c_str";

// SteamDatagramHostedAddress
SteamAPI_SteamDatagramHostedAddress_Clear :: (self: *SteamDatagramHostedAddress) #foreign steam "SteamAPI_SteamDatagramHostedAddress_Clear";
SteamAPI_SteamDatagramHostedAddress_GetPopID :: (self: *SteamDatagramHostedAddress) -> SteamNetworkingPOPID #foreign steam "SteamAPI_SteamDatagramHostedAddress_GetPopID";
SteamAPI_SteamDatagramHostedAddress_SetDevAddress :: (self: *SteamDatagramHostedAddress, nIP: uint32, nPort: uint16, popid: SteamNetworkingPOPID) #foreign steam "SteamAPI_SteamDatagramHostedAddress_SetDevAddress";


