#import "Basic";
#import "File";
#import "String";
#import "Hash_Table";
JSON :: #import "Jason";

steam_api_flat :: "sdk/public/steam/steam_api_flat.h";
steam_api_json :: "sdk/public/steam/steam_api.json";
output_filename :: "steam_api_flat.jai";


Replacement :: struct {
    before : string;
    after  : string;
}

replacements :: Replacement.[
    .{"const ", ""},
    .{"unsigned short", "u16"},
    .{"unsigned int", "u32"},
    .{"ISteamHTMLSurface::", ""},
];

type_replacements :: Replacement.[
    .{"const ", ""},
    .{"unsigned ", "u"},
];

typedef_replacements :: Replacement.[
    .{"char [1024]", "[1024] char"},
    .{"int", "s64"},
    .{"short", "s16"},
    .{"unsigned char [8]", "[8] u8"},
    .{"unsigned char", "u8"},
    .{"unsigned int", "uint"},
    .{"unsigned long long", "u64"},
    .{"unsigned short", "u16"},
    .{"signed char", "s8"},
    .{"long long", "s64"},
    .{"void *", "*void"},
];

const_val_replacements :: Replacement.[
    .{"0xffffffffffffffffull", "0xffffffffffffffff"},
    .{" 16U ", " 16 "},
    .{" 8U ", " 8 "},
    .{" ( uint32 ) ", " cast(uint32) "},
    .{"'d'", "#char \"d\""},
    .{"'e'", "#char \"e\""},
    .{"'v'", "#char \"v\""},
    .{"( SteamItemInstanceID_t )", "cast(SteamItemInstanceID_t)"},
];

builder: String_Builder;

out :: (format: string, args: .. Any) #expand {
    print_to_builder(*`builder, format, .. args);
}

main :: () {
    init_string_builder(*builder);
    defer reset(*builder);


    file_data, success := read_entire_file(steam_api_flat);
    if !success {
        print("Failed to open %", steam_api_flat);
        exit(1);
    }

    convert_steam_api_flat(file_data);


    file_data, success =  read_entire_file(steam_api_json);
    if !success {
        print("Failed to open %", steam_api_flat);
        exit(1);
    }

    convert_steam_api_json(file_data);


    write_entire_file(output_filename, builder_to_string(*builder));
}


convert_steam_api_flat :: (file_data: string) {

    rows := split(file_data, "\n");

    in_header := true;
    just_emit_newline := false;

    // steam_api_flat.h is autogenerated, therefor we make some assumptions
    // about parsing it.
    // a) Spaces only appear singly
    // b) Each comment section header is a class name
    // c) & and ** in parameters are always fully spaced

    for row, line_number: rows {
        if in_header {
            if starts_with(row, "//")
                continue;
            else
                in_header = false;
        }

        if starts_with(row, "#") continue;

        line := trim(row, " \t\n\r");

        if line == "" {
            if !just_emit_newline  out("\n");
            just_emit_newline = true;
            continue;
        }
        else
            just_emit_newline = false;

        if starts_with(line, "typedef") {
            // typedef old new; // comment
            parts := split(line, ";");
            types := split(parts[0], " ");
            out("% :: %;%\n", types[2], types[1], parts[1]);
        }
        else if starts_with(line, "//") {
            // // ClassName
            out("%\n", line);
            //out("% :: void;\n", split(line, " ")[1]);
        }
        else if starts_with(line, "S_API") {
            for replacements  line = replace(line, it.before, it.after);
            sections := split(line, "(");
            header := split(sections[0], " ");
            if header.count == 4 && header[2] != "*" || header.count > 4 {
                print("WTF on line %\n", line_number + 1);
            }
            return_type := header[1];
            return_is_pointer := false;
            proc_name := header[2];
            if proc_name == "*" {
                return_is_pointer = true;
                proc_name = header[3];
            }
            else if starts_with(proc_name, "*") {
                return_is_pointer = true;
                proc_name = slice(proc_name, 1, proc_name.count - 1);
            }

            return_char := ifx return_is_pointer  "*" else "";
            if return_type == "int"  return_type = "s32";

            parameters := split(split(sections[1], ")")[0], ",");

            out("% :: (", proc_name);

            for parameter, index: parameters {
                if index != 0  out(", ");
                parts := split(trim(parameter), " ");
                parameter_type := parts[0];
                parameter_name := parts[parts.count-1];
                pointer_char := "";
                if ends_with(parameter_type, "*") {
                    parameter_type = slice(parameter_type, 0, parameter_type.count-1);
                    pointer_char = "*";
                }
                else if parts.count == 3 {
                    if parts[1] == "*" || parts[1] == "&" // wing and prayer & -> *
                        pointer_char = "*";
                    else if parts[1] == "**"
                        pointer_char = "**";
                    else
                        print("WTF on line %\n", line_number + 1);
                }
                if parameter_type == "int"  parameter_type = "s32";

                out("%1: %2%3", parameter_name, pointer_char, parameter_type);
            }

            if return_type == "void"
                out(") #foreign steam;\n");
            else
                out(") -> %1%2 #foreign steam;\n", return_char, return_type);
        }

    }

}


convert_steam_api_json :: (file_data: string) {
    root, success := JSON.json_parse_string(file_data);

    traverse_node :: (key: string, node: JSON.JSON_Value, depth: int = 0) {
        const_name : JSON.JSON_Value;
        const_type : JSON.JSON_Value;
        const_val  : JSON.JSON_Value;
        success : bool;

        if node.type == {
        case .BOOLEAN;

        case .NUMBER;

        case .STRING;
            if key == {
                case "classname";
                out("% :: void;\n", node.value.str);
            }

        case .OBJECT;
            for node.value.object {
                traverse_node(it_index, it, depth + 1);
            }

        case .ARRAY;
            for node.value.array {
                traverse_node(key, it, depth + 1);
            }
            if key == {
                case "consts";
                if depth == 1 {
                    out("\n");
                    for node.value.array {
                        object := it.value.object;
                        const_name := get_str(object, "constname");
                        const_type := get_str(object, "consttype", type_replacements);
                        const_val  := get_str(object, "constval", const_val_replacements);
                        out("% : % : %;\n", const_name, const_type, const_val);
                    }
                }

                case "typedefs";
                if depth == 1 {
                    out("\n");
                    for node.value.array {
                        object := it.value.object;
                        typedef_before := get_str(object, "type");
                        typedef_after  := get_str(object, "typedef");
                        if contains(typedef_before, "(*)")
                            typedef_before = "*void";
                        else {
                            for typedef_replacements {
                                if typedef_before == it.before {
                                    typedef_before = it.after;
                                }
                            }
                        }
                        out("% :: %;\n", typedef_after, typedef_before);
                    }
                }

                case "enums";
                //if depth == 1 {
                    for node.value.array {
                        object := it.value.object;
                        enum_name := get_str(object, "enumname");
                        enum_values := get_array(object, "values");
                        //print("%\n", enum_values);
                        //print("A");
                        out("\n% :: enum s32 {\n", enum_name);
                        for enum_values {
                            object := it.value.object;
                            name := get_str(object, "name");
                            value := get_str(object, "value");
                            out("    % :: %;\n", name, value);
                        }
                        out("}\n");
                    }
                //}

                case "structs";
                if depth == 1 {
                    for node.value.array {
                        object := it.value.object;
                        struct_name := get_str(object, "struct");
                        struct_fields := get_array(object, "fields");
                        out("\n% :: struct {\n", struct_name);
                        for struct_fields {
                            object := it.value.object;
                            field_name := get_str(object, "fieldname");
                            field_type := get_str(object, "fieldtype", type_replacements);
                            if field_type == "int"  field_type = "s32";
                            if ends_with(field_type, "**")
                                field_type = sprint("**%", slice(field_type, 0, field_type.count - 2));
                            else if ends_with(field_type, "*")
                                field_type = sprint("*%", slice(field_type, 0, field_type.count - 1));
                            else if contains(field_type, "(*)")
                                field_type = "*void";
                            bracket := index_of_string(field_type, "[");
                            if bracket == -1
                                out("    % : %;\n", field_name, field_type);
                            else
                                out("    % : % %;\n", field_name,
                                                        slice(field_type, bracket, field_type.count - bracket),
                                                        slice(field_type, 0, bracket));
                        }
                        out("}\n");
                    }
                }

                case "callback_structs";
                if depth == 1 {
                    for node.value.array {
                        object := it.value.object;
                        struct_name := get_str(object, "struct");
                        struct_fields := get_array(object, "fields");
                        out("\n% :: struct {\n", struct_name);
                        for struct_fields {
                            object := it.value.object;
                            field_name := get_str(object, "fieldname");
                            field_type := get_str(object, "fieldtype", type_replacements);
                            if field_type == "int"  field_type = "s32";
                            coloncolon := index_of_string(field_type, "::");
                            if coloncolon != -1  field_type = slice(field_type, coloncolon + 2, field_type.count - (coloncolon + 2));
                            if ends_with(field_type, "**")
                                field_type = sprint("**%", slice(field_type, 0, field_type.count - 2));
                            else if ends_with(field_type, "*")
                                field_type = sprint("*%", slice(field_type, 0, field_type.count - 1));
                            else if contains(field_type, "(*)")
                                field_type = "*void";
                            bracket := index_of_string(field_type, "[");
                            if bracket == -1
                                out("    % : %;\n", field_name, field_type);
                            else
                                out("    % : % %;\n", field_name,
                                                        slice(field_type, bracket, field_type.count - bracket),
                                                        slice(field_type, 0, bracket));
                        }
                        out("}\n");
                    }
                }
            }
        }
    }

    root_value : JSON.JSON_Value;
    traverse_node("", root);
}


get_str :: (object: *JSON.JSON_Object, key: string) -> string {
    value, success := table_find(<<object, key);
    if success  return value.value.str;
    else        return "";
}


get_str :: (object: *JSON.JSON_Object, key: string, replacements: [] Replacement) -> string {
    value, success := table_find(<<object, key);
    if success  {
        s := value.value.str;
        for replacements  s = replace(s, it.before, it.after);
        return s;
    }
    else        return "";
}


get_obj :: (object: *JSON.JSON_Object, key: string) -> *JSON.JSON_Object {
    value, success := table_find(<<object, key);
    if success  return value.value.object;
    else        return null;
}

get_array :: (object: *JSON.JSON_Object, key: string) -> [..]JSON.JSON_Value {
    value, success := table_find(<<object, key);
    return value.value.array;
}
